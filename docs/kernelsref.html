<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>1. Kernels reference &#8212; lsqfitgp documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=4f649999" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css?v=28c8e701" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js?v=42f5af75"></script>
    <script src="_static/doctools.js?v=888ff710"></script>
    <script src="_static/sphinx_highlight.js?v=4825356b"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="2. Generic kernel classes" href="kernel.html" />
    <link rel="prev" title="Reference manual" href="reference.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">lsqfitgp</a></h1>



<p class="blurb">A general purpose Gaussian process regression module</p>




<p>
<iframe src="https://ghbtns.com/github-btn.html?user=Gattocrucco&repo=lsqfitgp&type=star&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>





<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="userguide.html">User guide</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="reference.html">Reference manual</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">1. Kernels reference</a></li>
<li class="toctree-l2"><a class="reference internal" href="kernel.html">2. Generic kernel classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="kerneldec.html">3. Kernel decorators</a></li>
<li class="toctree-l2"><a class="reference internal" href="kernelop.html">4. Kernel operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="deriv.html">5. Derivative specification</a></li>
<li class="toctree-l2"><a class="reference internal" href="gp.html">6. Gaussian process class</a></li>
<li class="toctree-l2"><a class="reference internal" href="array.html">7. Structured arrays wrapping</a></li>
<li class="toctree-l2"><a class="reference internal" href="fit.html">8. Fitting</a></li>
<li class="toctree-l2"><a class="reference internal" href="raniter.html">9. Random sampling</a></li>
<li class="toctree-l2"><a class="reference internal" href="copula.html">10. Copula factories</a></li>
<li class="toctree-l2"><a class="reference internal" href="bayestree.html">11. BART</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="examples.html">Examples</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
  <li><a href="reference.html">Reference manual</a><ul>
      <li>Previous: <a href="reference.html" title="previous chapter">Reference manual</a></li>
      <li>Next: <a href="kernel.html" title="next chapter"><span class="section-number">2. </span>Generic kernel classes</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
              <div class="related top">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="reference.html" title="Previous document">Reference manual</a>
        </li>
        <li>
          <a href="kernel.html" title="Next document"><span class="section-number">2. </span>Generic kernel classes</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          

          <div class="body" role="main">
            
  <section id="kernels-reference">
<span id="kernels"></span><h1><span class="section-number">1. </span>Kernels reference<a class="headerlink" href="#kernels-reference" title="Permalink to this heading">Â¶</a></h1>
<p>This is a list of all the specific kernels implemented in <a class="reference internal" href="index.html#module-lsqfitgp" title="lsqfitgp"><code class="xref py py-mod docutils literal notranslate"><span class="pre">lsqfitgp</span></code></a>.</p>
<p>Kernels are reported with a simplified signature where the positional arguments
are <code class="xref py py-obj docutils literal notranslate"><span class="pre">r</span></code> or <code class="xref py py-obj docutils literal notranslate"><span class="pre">r2</span></code> if the kernel is isotropic, <code class="xref py py-obj docutils literal notranslate"><span class="pre">delta</span></code> if it is stationary, or
<code class="xref py py-obj docutils literal notranslate"><span class="pre">x</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">y</span></code> for generic kernels, and with only the keyword arguments specific to
the kernel. All kernels also understand the general keyword arguments of
<a class="reference internal" href="kernel.html#lsqfitgp.Kernel" title="lsqfitgp.Kernel"><code class="xref py py-class docutils literal notranslate"><span class="pre">Kernel</span></code></a> (or their specific superclass), while there are no positional
arguments when instantiating the kernel and the call signature of instances is
always <code class="xref py py-obj docutils literal notranslate"><span class="pre">x</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">y</span></code>.</p>
<p>Example: the kernel <a class="reference internal" href="#lsqfitgp.GammaExp" title="lsqfitgp.GammaExp"><code class="xref py py-class docutils literal notranslate"><span class="pre">GammaExp</span></code></a> is listed as <code class="docutils literal notranslate"><span class="pre">GammaExp(r,</span> <span class="pre">gamma=1)</span></code>.
This means you could use it this way:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">lsqfitgp</span> <span class="k">as</span> <span class="nn">lgp</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="n">kernel</span> <span class="o">=</span> <span class="n">lgp</span><span class="o">.</span><span class="n">GammaExp</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="mf">1.4</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
<span class="n">covmat</span> <span class="o">=</span> <span class="n">kernel</span><span class="p">(</span><span class="n">x</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:])</span>
</pre></div>
</div>
<p>On multidimensional input, isotropic kernels will compute the euclidean
distance. In general non-isotropic kernels will act separately on each
dimension, i.e., <span class="math notranslate nohighlight">\(k(x_1,y_1,x_2,y_2) = k(x_1,y_1) k(x_2,y_2)\)</span>, apart from
kernels defined in terms of the dot product.</p>
<p>For all isotropic and stationary (i.e., depending only on <span class="math notranslate nohighlight">\(x - y\)</span>)
kernels <span class="math notranslate nohighlight">\(k(x, x) = 1\)</span>, and the typical lengthscale is approximately 1 for
default values of the keyword parameters, apart from some specific cases like
<a class="reference internal" href="#lsqfitgp.Constant" title="lsqfitgp.Constant"><code class="xref py py-class docutils literal notranslate"><span class="pre">Constant</span></code></a>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>You may encounter problems with second derivatives for
<a class="reference internal" href="#lsqfitgp.CausalExpQuad" title="lsqfitgp.CausalExpQuad"><code class="xref py py-class docutils literal notranslate"><span class="pre">CausalExpQuad</span></code></a>, <a class="reference internal" href="#lsqfitgp.FracBrownian" title="lsqfitgp.FracBrownian"><code class="xref py py-class docutils literal notranslate"><span class="pre">FracBrownian</span></code></a>, <a class="reference internal" href="#lsqfitgp.NNKernel" title="lsqfitgp.NNKernel"><code class="xref py py-class docutils literal notranslate"><span class="pre">NNKernel</span></code></a>, and with
first derivatives too for <a class="reference internal" href="#lsqfitgp.Wendland" title="lsqfitgp.Wendland"><code class="xref py py-class docutils literal notranslate"><span class="pre">Wendland</span></code></a> (but only in more than one
dimension). <a class="reference internal" href="#lsqfitgp.Color" title="lsqfitgp.Color"><code class="xref py py-class docutils literal notranslate"><span class="pre">Color</span></code></a> stops working for <span class="math notranslate nohighlight">\(n &gt; 20\)</span>.</p>
</div>
<section id="index">
<h2><span class="section-number">1.1. </span>Index<a class="headerlink" href="#index" title="Permalink to this heading">Â¶</a></h2>
<section id="isotropic-kernels">
<h3><span class="section-number">1.1.1. </span>Isotropic kernels<a class="headerlink" href="#isotropic-kernels" title="Permalink to this heading">Â¶</a></h3>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#lsqfitgp.Bessel" title="lsqfitgp.Bessel"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bessel</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.Cauchy" title="lsqfitgp.Cauchy"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cauchy</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.CausalExpQuad" title="lsqfitgp.CausalExpQuad"><code class="xref py py-class docutils literal notranslate"><span class="pre">CausalExpQuad</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.Constant" title="lsqfitgp.Constant"><code class="xref py py-class docutils literal notranslate"><span class="pre">Constant</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.ExpQuad" title="lsqfitgp.ExpQuad"><code class="xref py py-class docutils literal notranslate"><span class="pre">ExpQuad</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.GammaExp" title="lsqfitgp.GammaExp"><code class="xref py py-class docutils literal notranslate"><span class="pre">GammaExp</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.Log" title="lsqfitgp.Log"><code class="xref py py-class docutils literal notranslate"><span class="pre">Log</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.Matern" title="lsqfitgp.Matern"><code class="xref py py-class docutils literal notranslate"><span class="pre">Matern</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.Maternp" title="lsqfitgp.Maternp"><code class="xref py py-class docutils literal notranslate"><span class="pre">Maternp</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.Wendland" title="lsqfitgp.Wendland"><code class="xref py py-class docutils literal notranslate"><span class="pre">Wendland</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.White" title="lsqfitgp.White"><code class="xref py py-class docutils literal notranslate"><span class="pre">White</span></code></a></p></li>
</ul>
</div></blockquote>
</section>
<section id="stationary-kernels">
<h3><span class="section-number">1.1.2. </span>Stationary kernels<a class="headerlink" href="#stationary-kernels" title="Permalink to this heading">Â¶</a></h3>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#lsqfitgp.AR" title="lsqfitgp.AR"><code class="xref py py-class docutils literal notranslate"><span class="pre">AR</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.Celerite" title="lsqfitgp.Celerite"><code class="xref py py-class docutils literal notranslate"><span class="pre">Celerite</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.Circular" title="lsqfitgp.Circular"><code class="xref py py-class docutils literal notranslate"><span class="pre">Circular</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.Color" title="lsqfitgp.Color"><code class="xref py py-class docutils literal notranslate"><span class="pre">Color</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.Cos" title="lsqfitgp.Cos"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cos</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.Expon" title="lsqfitgp.Expon"><code class="xref py py-class docutils literal notranslate"><span class="pre">Expon</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.Harmonic" title="lsqfitgp.Harmonic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Harmonic</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.HoleEffect" title="lsqfitgp.HoleEffect"><code class="xref py py-class docutils literal notranslate"><span class="pre">HoleEffect</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.MA" title="lsqfitgp.MA"><code class="xref py py-class docutils literal notranslate"><span class="pre">MA</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.Periodic" title="lsqfitgp.Periodic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Periodic</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.Pink" title="lsqfitgp.Pink"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pink</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.Sinc" title="lsqfitgp.Sinc"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sinc</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.StationaryFracBrownian" title="lsqfitgp.StationaryFracBrownian"><code class="xref py py-class docutils literal notranslate"><span class="pre">StationaryFracBrownian</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.Zeta" title="lsqfitgp.Zeta"><code class="xref py py-class docutils literal notranslate"><span class="pre">Zeta</span></code></a></p></li>
</ul>
</div></blockquote>
</section>
<section id="other-kernels">
<h3><span class="section-number">1.1.3. </span>Other kernels<a class="headerlink" href="#other-kernels" title="Permalink to this heading">Â¶</a></h3>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#lsqfitgp.BART" title="lsqfitgp.BART"><code class="xref py py-class docutils literal notranslate"><span class="pre">BART</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.BagOfWords" title="lsqfitgp.BagOfWords"><code class="xref py py-class docutils literal notranslate"><span class="pre">BagOfWords</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.BrownianBridge" title="lsqfitgp.BrownianBridge"><code class="xref py py-class docutils literal notranslate"><span class="pre">BrownianBridge</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.Categorical" title="lsqfitgp.Categorical"><code class="xref py py-class docutils literal notranslate"><span class="pre">Categorical</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.Decaying" title="lsqfitgp.Decaying"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decaying</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.FracBrownian" title="lsqfitgp.FracBrownian"><code class="xref py py-class docutils literal notranslate"><span class="pre">FracBrownian</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.Gibbs" title="lsqfitgp.Gibbs"><code class="xref py py-class docutils literal notranslate"><span class="pre">Gibbs</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.Linear" title="lsqfitgp.Linear"><code class="xref py py-class docutils literal notranslate"><span class="pre">Linear</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.NNKernel" title="lsqfitgp.NNKernel"><code class="xref py py-class docutils literal notranslate"><span class="pre">NNKernel</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.OrnsteinUhlenbeck" title="lsqfitgp.OrnsteinUhlenbeck"><code class="xref py py-class docutils literal notranslate"><span class="pre">OrnsteinUhlenbeck</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.Rescaling" title="lsqfitgp.Rescaling"><code class="xref py py-class docutils literal notranslate"><span class="pre">Rescaling</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.Taylor" title="lsqfitgp.Taylor"><code class="xref py py-class docutils literal notranslate"><span class="pre">Taylor</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.Wiener" title="lsqfitgp.Wiener"><code class="xref py py-class docutils literal notranslate"><span class="pre">Wiener</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.WienerIntegral" title="lsqfitgp.WienerIntegral"><code class="xref py py-class docutils literal notranslate"><span class="pre">WienerIntegral</span></code></a></p></li>
</ul>
</div></blockquote>
</section>
</section>
<section id="documentation">
<h2><span class="section-number">1.2. </span>Documentation<a class="headerlink" href="#documentation" title="Permalink to this heading">Â¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="lsqfitgp.AR">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">AR</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">delta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxlag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slnr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lnc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Gattocrucco/lsqfitgp/blob/master/src/lsqfitgp/_kernels/_arma.py#L69-L185"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lsqfitgp.AR" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Discrete autoregressive kernel.</p>
<p>You have to specify one and only one of the sets of parameters
<code class="docutils literal notranslate"><span class="pre">phi+maxlag</span></code>, <code class="docutils literal notranslate"><span class="pre">gamma+maxlag</span></code>, <code class="docutils literal notranslate"><span class="pre">slnr+lnc</span></code>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>phi</strong><span class="classifier">(p,) real</span></dt><dd><p>The autoregressive coefficients at lag 1â¦p.</p>
</dd>
<dt><strong>gamma</strong><span class="classifier">(p + 1,) real</span></dt><dd><p>The autocovariance at lag 0â¦p.</p>
</dd>
<dt><strong>maxlag</strong><span class="classifier">int</span></dt><dd><p>The maximum lag that the kernel will be evaluated on. If the actual
inputs produce higher lags, the missing values are filled with <code class="docutils literal notranslate"><span class="pre">nan</span></code>.</p>
</dd>
<dt><strong>slnr</strong><span class="classifier">(nr,) real</span></dt><dd><p>The real roots of the characteristic polynomial, expressed in the
following way: <code class="docutils literal notranslate"><span class="pre">sign(slnr)</span></code> is the sign of the root, and
<code class="docutils literal notranslate"><span class="pre">abs(snlr)</span></code> is the natural logarithm of the absolute value.</p>
</dd>
<dt><strong>lnc</strong><span class="classifier">(nc,) complex</span></dt><dd><p>The natural logarithm of the complex roots of the characteristic
polynomial (<span class="math notranslate nohighlight">\(\log z = \log|z| + i\arg z\)</span>), where each root
also stands for its paired conjugate.</p>
<p>In <code class="docutils literal notranslate"><span class="pre">slnr</span></code> and <code class="docutils literal notranslate"><span class="pre">lnc</span></code>, the multiplicity of a root is expressed by
repeating the root in the array (not necessarily next to each other).
Only exact repetition counts; very close yet distinct roots are treated
as separate and lead to numerical instability, in particular complex
roots very close to the real line. An exactly real complex root behaves
like a pair of identical real roots. Two complex roots also count as
equal if conjugate, and the argument is standardized to <span class="math notranslate nohighlight">\([0,
2\pi)\)</span>.</p>
</dd>
<dt><strong>norm</strong><span class="classifier">bool</span></dt><dd><p>If True, normalize the autocovariance to be 1 at lag 0. If False
(default), normalize such that the variance of the generating noise is
1, or use the user-provided normalization if <code class="docutils literal notranslate"><span class="pre">gamma</span></code> is specified.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This is the covariance function of a stationary autoregressive process,
which is defined recursively as</p>
<div class="math notranslate nohighlight">
\[y_i = \sum_{k=1}^p \phi_k y_{i-k} + \epsilon_i,\]</div>
<p>where <span class="math notranslate nohighlight">\(\epsilon_i\)</span> is white noise, i.e.,
<span class="math notranslate nohighlight">\(\operatorname{Cov}[\epsilon_i, \epsilon_j] = \delta_{ij}\)</span>. The
length <span class="math notranslate nohighlight">\(p\)</span> of the vector of coefficients <span class="math notranslate nohighlight">\(\boldsymbol\phi\)</span>
is the âorderâ of the process.</p>
<p>The covariance function can be expressed in two ways. First as the same
recursion defining the process:</p>
<div class="math notranslate nohighlight">
\[\gamma_m = \sum_{k=1}^p \phi_k \gamma_{m-k} + \delta_{m0},\]</div>
<p>where <span class="math notranslate nohighlight">\(\gamma_m \equiv \operatorname{Cov}[y_i, y_{i+m}]\)</span>. This is
called âYule-Walker equation.â Second, as a linear combination of mixed
power-exponentials:</p>
<div class="math notranslate nohighlight">
\[\gamma_m = \sum_{j=1}^n
            \sum_{l=1}^{\mu_j}
            a_{jl} |m|^{l-1} x_j^{-|m|},\]</div>
<p>where <span class="math notranslate nohighlight">\(x_j\)</span> and <span class="math notranslate nohighlight">\(\mu_j\)</span> are the (complex) roots and
corresponding multiplicities of the âcharacteristic polynomialâ</p>
<div class="math notranslate nohighlight">
\[P(x) = 1 - \sum_{k=1}^p \phi_k x^k,\]</div>
<p>and the <span class="math notranslate nohighlight">\(a_{jl}\)</span> are uniquely determined complex coefficients. The
<span class="math notranslate nohighlight">\(\boldsymbol\phi\)</span> vector is valid iff <span class="math notranslate nohighlight">\(|x_j|&gt;1, \forall j\)</span>.</p>
<p>There are three alternative parametrization for this kernel.</p>
<p>If you specify <code class="docutils literal notranslate"><span class="pre">phi</span></code>, the first terms of the covariance are computed
solving the Yule-Walker equation, and then evolved up to <code class="docutils literal notranslate"><span class="pre">maxlag</span></code>. It
is necessary to specify <code class="xref py py-obj docutils literal notranslate"><span class="pre">maxlag</span></code> instead of letting the code figure it out
from the actual inputs for technical reasons.</p>
<p>Likewise, if you specify <code class="docutils literal notranslate"><span class="pre">gamma</span></code>, the coefficients are obtained with
Yule-Walker and then used to evolve the covariance. The only difference is
that the normalization can be different: starting from <code class="docutils literal notranslate"><span class="pre">phi</span></code>, the variance
of the generating noise <span class="math notranslate nohighlight">\(\epsilon\)</span> is fixed to 1, while giving
<code class="docutils literal notranslate"><span class="pre">gamma</span></code> directly implies an arbitrary value.</p>
<p>Instead, if you specify the roots with <code class="docutils literal notranslate"><span class="pre">slnr</span></code> and <code class="docutils literal notranslate"><span class="pre">lnc</span></code>, the coefficients
are obtained from the polynomial defined in terms of the roots, and then
the amplitudes <span class="math notranslate nohighlight">\(a_{jl}\)</span> are computed by solving a linear system with
the covariance (from YW) as RHS. Finally, the full covariance function is
evaluated with the analytical expression.</p>
<p>The reasons for using the logarithm are that 1) in practice the roots are
tipically close to 1, so the logarithm is numerically more accurate, and 2)
the logarithm is readily interpretable as the inverse of the correlation
length.</p>
<dl class="py method">
<dt class="sig sig-object py" id="lsqfitgp.AR.extend_gamma">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">extend_gamma</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gamma</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Gattocrucco/lsqfitgp/blob/master/src/lsqfitgp/_kernels/_arma.py#L435-L458"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lsqfitgp.AR.extend_gamma" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Extends values of the covariance function to higher lags.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>gamma</strong><span class="classifier">(m,) array</span></dt><dd><p>The autocovariance at lag q-m+1â¦q, with q &gt;= 0 and m &gt;= p + 1.</p>
</dd>
<dt><strong>phi</strong><span class="classifier">(p,) array</span></dt><dd><p>The autoregressive coefficients at lag 1â¦p.</p>
</dd>
<dt><strong>n</strong><span class="classifier">int</span></dt><dd><p>The number of new values to generate.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>ext</strong><span class="classifier">(m + n,) array</span></dt><dd><p>The autocovariance at lag q-m+1â¦q+n.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lsqfitgp.AR.gamma_from_phi">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">gamma_from_phi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">phi</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Gattocrucco/lsqfitgp/blob/master/src/lsqfitgp/_kernels/_arma.py#L407-L433"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lsqfitgp.AR.gamma_from_phi" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Determine the covariance from the autoregressive coefficients.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>phi</strong><span class="classifier">(p,) array</span></dt><dd><p>The autoregressive coefficients at lag 1â¦p.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>gamma</strong><span class="classifier">(p + 1,) array</span></dt><dd><p>The autocovariance at lag 0â¦p. The normalization is
with noise variance 1.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The result is wildly inaccurate for roots with high multiplicity and/or
close to 1.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lsqfitgp.AR.phi_from_gamma">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">phi_from_gamma</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gamma</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Gattocrucco/lsqfitgp/blob/master/src/lsqfitgp/_kernels/_arma.py#L389-L405"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lsqfitgp.AR.phi_from_gamma" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Determine the autoregressive coefficients from the covariance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>gamma</strong><span class="classifier">(p + 1,) array</span></dt><dd><p>The autocovariance at lag 0â¦p.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>phi</strong><span class="classifier">(p,) array</span></dt><dd><p>The autoregressive coefficients at lag 1â¦p.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lsqfitgp.AR.phi_from_roots">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">phi_from_roots</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">slnr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lnc</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Gattocrucco/lsqfitgp/blob/master/src/lsqfitgp/_kernels/_arma.py#L460-L505"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lsqfitgp.AR.phi_from_roots" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Determine the autoregressive coefficients from the roots of the
characteristic polynomial.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>slnr</strong><span class="classifier">(nr,) real</span></dt><dd><p>The real roots of the characteristic polynomial, expressed in the
following way: <code class="docutils literal notranslate"><span class="pre">sign(slnr)</span></code> is the sign of the root, and
<code class="docutils literal notranslate"><span class="pre">abs(snlr)</span></code> is the natural logarithm of the absolute value.</p>
</dd>
<dt><strong>lnc</strong><span class="classifier">(nc,) complex</span></dt><dd><p>The natural logarithm of the complex roots of the characteristic
polynomial (<span class="math notranslate nohighlight">\(\log z = \log|z| + i\arg z\)</span>), where each root
also stands for its paired conjugate.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>phi</strong><span class="classifier">(p,) real</span></dt><dd><p>The autoregressive coefficients at lag 1â¦p, with p = nr + 2 nc.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<img alt="_images/kernelsref-AR.png" src="_images/kernelsref-AR.png" />
<img alt="_images/kernelsref-AR-samples.png" src="_images/kernelsref-AR-samples.png" />
<dl class="py class">
<dt class="sig sig-object py" id="lsqfitgp.BART">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">BART</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.95</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxd</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">splits</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pnt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">intercept</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Gattocrucco/lsqfitgp/blob/master/src/lsqfitgp/_kernels/_bart.py#L36-L217"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lsqfitgp.BART" title="Permalink to this definition">Â¶</a></dt>
<dd><p>BART kernel.</p>
<p>Good default parameters: <code class="docutils literal notranslate"><span class="pre">gamma=0.95</span></code>; <code class="docutils literal notranslate"><span class="pre">maxd=4,</span> <span class="pre">reset=2</span></code> if not fitting
the hyperparameters (<code class="docutils literal notranslate"><span class="pre">alpha</span></code> and <code class="docutils literal notranslate"><span class="pre">beta</span></code>), <code class="docutils literal notranslate"><span class="pre">maxd=10,</span> <span class="pre">reset=[2,4,6,8]</span></code>
otherwise. Derivatives are faster with forward autodiff.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x, y</strong><span class="classifier">arrays</span></dt><dd><p>Input points. The array type can be structured, in which case every leaf
field represents a dimension; or unstructured, which specifies a single
dimension.</p>
</dd>
<dt><strong>alpha, beta</strong><span class="classifier">scalar</span></dt><dd><p>The parameters of the branching probability.</p>
</dd>
<dt><strong>maxd</strong><span class="classifier">int</span></dt><dd><p>The maximum depth of the trees.</p>
</dd>
<dt><strong>splits</strong><span class="classifier">pair of arrays</span></dt><dd><p>The first is an int (p,) array containing the number of splitting
points along each dimension, the second has shape (n, p) and contains
the sorted splitting points in each column, filled with high values
after the length.</p>
</dd>
<dt><strong>gamma</strong><span class="classifier">scalar or str</span></dt><dd><p>Interpolation coefficient in [0, 1] between a lower and a upper
bound on the infinite maxd limit, or a string âautoâ indicating to
use a formula which depends on alpha, beta, maxd and the number of
covariates, empirically calibrated on maxd from 1 to 3. Default 1
(upper bound).</p>
</dd>
<dt><strong>pnt</strong><span class="classifier">(maxd + 1,) array, optional</span></dt><dd><p>Nontermination probabilities at depths 0â¦maxd. If specified,
<code class="docutils literal notranslate"><span class="pre">alpha</span></code>, <code class="docutils literal notranslate"><span class="pre">beta</span></code> and <code class="docutils literal notranslate"><span class="pre">maxd</span></code> are ignored.</p>
</dd>
<dt><strong>intercept</strong><span class="classifier">bool</span></dt><dd><p>The correlation is in [1 - alpha, 1] (or [1 - pnt[0], 1] when using
pnt). If intercept=False, it is rescaled to [0, 1]. Default True.</p>
</dd>
<dt><strong>weights</strong><span class="classifier">(p,) array</span></dt><dd><p>Unnormalized selection probabilities for the covariate axes. If not
specified, all axes have the same probability to be selected for
splitting.</p>
</dd>
<dt><strong>reset</strong><span class="classifier">int or sequence of int, optional</span></dt><dd><p>List of depths at which the recursion is reset, in the sense that the
function value at a reset depth is evaluated on the initial inputs for
all recursion paths, instead of the modified input handed down by the
recursion. Default none.</p>
</dd>
<dt><strong>indices</strong><span class="classifier">bool</span></dt><dd><p>If False (default), the inputs <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code> represent coordinate values.
If True, they are taken to be already the indices of the points in the
splitting grid, as can be obtained with <a class="reference internal" href="#lsqfitgp.BART.indices_from_coord" title="lsqfitgp.BART.indices_from_coord"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BART.indices_from_coord</span></code></a>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This is the covariance function of the latent mean prior of BART (Bayesian
Additive Regression Trees) <a class="reference internal" href="#r0b7d3b51c950-1" id="id1">[1]</a> in the limit of an infinite number of
trees, and with an upper bound <span class="math notranslate nohighlight">\(D\)</span> on the depth of the trees. This
prior is the distribution of the function</p>
<div class="math notranslate nohighlight">
\[f(\mathbf x) = \lim_{m\to\infty}
\sum_{j=1}^m g(\mathbf x; T_j, M_j),\]</div>
<p>where each <span class="math notranslate nohighlight">\(g(\mathbf x; T_j, M_j)\)</span> is a decision tree evaluated at
<span class="math notranslate nohighlight">\(\mathbf x\)</span>, with structure <span class="math notranslate nohighlight">\(T_j\)</span> and leaf values <span class="math notranslate nohighlight">\(M_j\)</span>.
The trees are i.i.d., with the following distribution for <span class="math notranslate nohighlight">\(T_j\)</span>: for
a node at depth <span class="math notranslate nohighlight">\(d\)</span>, with <span class="math notranslate nohighlight">\(d = 0\)</span> for the root, the probability
of not being a leaf, conditional on its existence and its ancestors only, is</p>
<div class="math notranslate nohighlight">
\[P_d = \alpha (1+d)^{-\beta}, \quad
\alpha \in [0, 1], \quad \beta \ge 0.\]</div>
<p>For a non-leaf node, conditional on existence and ancestors, the splitting
variable has uniform distribution amongst the variables with any splitting
points not used by ancestors, and the splitting point has uniform
distribution amongst the available ones. The splitting points are fixed,
tipically from the data.</p>
<p>The distribution of leaves <span class="math notranslate nohighlight">\(M_j\)</span> is i.i.d. Normal with variance
<span class="math notranslate nohighlight">\(1/m\)</span>, such that <span class="math notranslate nohighlight">\(f(x)\)</span> has variance 1. In the limit
<span class="math notranslate nohighlight">\(m\to\infty\)</span>, the distribution of <span class="math notranslate nohighlight">\(f(x)\)</span> becomes a Gaussian
process.</p>
<p>Since the trees are independent, the covariance function can be computed
for a single tree. Consider two coordinates <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span>, with
<span class="math notranslate nohighlight">\(x \le y\)</span>. Let <span class="math notranslate nohighlight">\(n^-\)</span>, <span class="math notranslate nohighlight">\(n^0\)</span> and <span class="math notranslate nohighlight">\(n^+\)</span> be the
number of splitting points respectively before <span class="math notranslate nohighlight">\(x\)</span>, between
<span class="math notranslate nohighlight">\(x\)</span>, <span class="math notranslate nohighlight">\(y\)</span> and after <span class="math notranslate nohighlight">\(y\)</span>. Next, define <span class="math notranslate nohighlight">\(\mathbf
n^-\)</span>, <span class="math notranslate nohighlight">\(\mathbf n^0\)</span> and <span class="math notranslate nohighlight">\(\mathbf n^+\)</span> as the vectors of such
quantities for each dimension, with a total of <span class="math notranslate nohighlight">\(p\)</span> dimensions, and
<span class="math notranslate nohighlight">\(\mathbf n = \mathbf n^- + \mathbf n^0 + \mathbf n^+\)</span>. Then the
covariance function can be written recursively as</p>
<div class="math notranslate nohighlight">
\[\begin{split}\newcommand{\nvecs}{\mathbf n^-, \mathbf n^0, \mathbf n^+}
k(\mathbf x, \mathbf y) &amp;= k_0(\nvecs), \\
k_D(\nvecs) &amp;= 1 - (1 - \gamma) P_D,
    \quad \mathbf n^0 \ne \mathbf 0, \\
k_d(\mathbf 0, \mathbf 0, \mathbf 0) &amp;= 1, \\
k_d(\nvecs) &amp;= 1 - P_d \Bigg(1 - \frac1{W(\mathbf n)}
    \sum_{\substack{i=1 \\ n_i\ne 0}}^p
        \frac{w_i}{n_i} \Bigg( \\
        &amp;\qquad \sum_{k=0}^{n^-_i - 1}
        k_{d+1}(\mathbf n^-_{n^-_i=k}, \mathbf n^0, \mathbf n^+)
        + {} \\
        &amp;\qquad \sum_{k=0}^{n^+_i - 1}
        k_{d+1}(\mathbf n^-, \mathbf n^0, \mathbf n^+_{n^+_i=k})
    \Bigg)
\Bigg), \quad d &lt; D, \\
W(\mathbf n) &amp;= \sum_{\substack{i=1 \\ n_i\ne 0}}^p w_i.\end{split}\]</div>
<p>The introduction of a maximum depth <span class="math notranslate nohighlight">\(D\)</span> is necessary for
computational feasibility. As <span class="math notranslate nohighlight">\(D\)</span> increases, the result converges to
the one without depth limit. For <span class="math notranslate nohighlight">\(D \le 2\)</span> (the default value), the
covariance is implemented in closed form and takes <span class="math notranslate nohighlight">\(O(p)\)</span> to compute.
For <span class="math notranslate nohighlight">\(D &gt; 2\)</span>, the computational complexity grows exponentially as
<span class="math notranslate nohighlight">\(O(p(\bar np)^{D-2})\)</span>, where <span class="math notranslate nohighlight">\(\bar n\)</span> is the average number of splitting
points along a dimension.</p>
<p>In the maximum allowed depth is 1, i.e., either <span class="math notranslate nohighlight">\(D = 1\)</span> or
<span class="math notranslate nohighlight">\(\beta\to\infty\)</span>, the kernel assumes the simple form</p>
<div class="math notranslate nohighlight">
\[\begin{split}k(\mathbf x, \mathbf y) &amp;= 1 - P_0 \left(
    1 - Q + \frac Q{W(\mathbf n)}
    \sum_{\substack{i=1 \\ n_i\ne 0}}^p w_i
    \frac{n^0_i}{n_i} \right), \\
Q &amp;= \begin{cases}
    1 - (1 - \gamma) P_1 &amp; \mathbf n^0 \ne \mathbf 0, \\
    1 &amp; \mathbf n^0 = \mathbf 0,
\end{cases}\end{split}\]</div>
<p>which is separable along dimensions, i.e., it has no interactions.</p>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r0b7d3b51c950-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p>Hugh A. Chipman, Edward I. George, Robert E. McCulloch âBART:
Bayesian additive regression trees,â The Annals of Applied Statistics,
Ann. Appl. Stat. 4(1), 266-298, (March 2010).</p>
</div>
</div>
<p class="rubric">Methods</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#lsqfitgp.BART.splits_from_coord" title="lsqfitgp.BART.splits_from_coord"><code class="xref py py-obj docutils literal notranslate"><span class="pre">splits_from_coord</span></code></a>(x)</p></td>
<td><p>Generate splitting points from data.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#lsqfitgp.BART.indices_from_coord" title="lsqfitgp.BART.indices_from_coord"><code class="xref py py-obj docutils literal notranslate"><span class="pre">indices_from_coord</span></code></a>(x,Â splits)</p></td>
<td><p>Convert coordinates to indices w.r.t.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#lsqfitgp.BART.correlation" title="lsqfitgp.BART.correlation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">correlation</span></code></a>(splitsbefore_or_totalsplits,Â ...)</p></td>
<td><p>Compute the BART prior correlation between two points.</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="lsqfitgp.BART.correlation">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">correlation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">splitsbefore_or_totalsplits</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">splitsbetween_or_index1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">splitsafter_or_index2</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.95</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxd</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">debug</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pnt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">intercept</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">altinput</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Gattocrucco/lsqfitgp/blob/master/src/lsqfitgp/_kernels/_bart.py#L316-L470"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lsqfitgp.BART.correlation" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Compute the BART prior correlation between two points.</p>
<p>Apart from arguments <code class="docutils literal notranslate"><span class="pre">maxd</span></code>, <code class="docutils literal notranslate"><span class="pre">debug</span></code> and <code class="docutils literal notranslate"><span class="pre">reset</span></code>, this method is fully
vectorized.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>splitsbefore_or_totalsplits</strong><span class="classifier">int (p,) array</span></dt><dd><p>The number of splitting points less than the two points, separately
along each coordinate, or the total number of splits if <code class="docutils literal notranslate"><span class="pre">altinput</span></code>.</p>
</dd>
<dt><strong>splitsbetween_or_index1</strong><span class="classifier">int (p,) array</span></dt><dd><p>The number of splitting points between the two points, separately
along each coordinate, or the index in the splitting bins of the
first point if <code class="docutils literal notranslate"><span class="pre">altinput</span></code>, where 0 means to the left of the leftmost
splitting point.</p>
</dd>
<dt><strong>splitsafter_or_index2</strong><span class="classifier">int (p,) array</span></dt><dd><p>The number of splitting points greater than the two points,
separately along each coordinate, or the index in the splitting bins
of the second point if <code class="docutils literal notranslate"><span class="pre">altinput</span></code>.</p>
</dd>
<dt><strong>debug</strong><span class="classifier">bool</span></dt><dd><p>If True, disable shortcuts in the tree recursion. Default False.</p>
</dd>
<dt><strong>altinput</strong><span class="classifier">bool</span></dt><dd><p>If True, take as input the indices in the splitting bins of the
points instead of the counts of splitting points separating them,
and use a different implementation optimized for that case. Default
False. The <a class="reference internal" href="#lsqfitgp.BART" title="lsqfitgp.BART"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BART</span></code></a> kernel uses <code class="docutils literal notranslate"><span class="pre">altinput=True</span></code>.</p>
</dd>
<dt><strong>Other parameters</strong></dt><dd><p>See <a class="reference internal" href="#lsqfitgp.BART" title="lsqfitgp.BART"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BART</span></code></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>corr</strong><span class="classifier">scalar</span></dt><dd><p>The prior correlation.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lsqfitgp.BART.indices_from_coord">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">indices_from_coord</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">splits</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Gattocrucco/lsqfitgp/blob/master/src/lsqfitgp/_kernels/_bart.py#L278-L308"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lsqfitgp.BART.indices_from_coord" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Convert coordinates to indices w.r.t. splitting points.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array of numbers</span></dt><dd><p>The coordinates. Can be passed in two formats: 1) a structured
array where each leaf field represents a dimension, 2) a normal
array where the last axis runs over dimensions. In the structured
case, each index in any shaped field is a different dimension.</p>
</dd>
<dt><strong>splits</strong><span class="classifier">pair of arrays</span></dt><dd><p>The first is an int (p,) array containing the number of splitting
points along each dimension, the second has shape (n, p) and
contains the sorted splitting points in each column, filled with
high values after the length.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>ix</strong><span class="classifier">int array</span></dt><dd><p>An array with the same shape as <code class="docutils literal notranslate"><span class="pre">x</span></code>, unless <code class="docutils literal notranslate"><span class="pre">x</span></code> is a structured
array, in which case the last axis of <code class="docutils literal notranslate"><span class="pre">ix</span></code> is the flattened version
of the structured type. <code class="docutils literal notranslate"><span class="pre">ix</span></code> contains indices mapping <code class="docutils literal notranslate"><span class="pre">x</span></code> to
positions between splitting points along each coordinate, with the
following convention: index 0 means before the first split, index
i &gt; 0 means between split i - 1 and split i.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lsqfitgp.BART.splits_from_coord">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">splits_from_coord</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Gattocrucco/lsqfitgp/blob/master/src/lsqfitgp/_kernels/_bart.py#L223-L253"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lsqfitgp.BART.splits_from_coord" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Generate splitting points from data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array of numbers</span></dt><dd><p>The data. Can be passed in two formats: 1) a structured array where
each leaf field represents a dimension, 2) a normal array where the
last axis runs over dimensions. In the structured case, each
index in any shaped field is a different dimension.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>length</strong><span class="classifier">int (p,) array</span></dt><dd><p>The number of splitting points along each of <code class="docutils literal notranslate"><span class="pre">p</span></code> dimensions.</p>
</dd>
<dt><strong>splits</strong><span class="classifier">(n, p) array</span></dt><dd><p>Each column contains the sorted splitting points along a dimension.
The splitting points are the midpoints between consecutive values
appearing in <code class="xref py py-obj docutils literal notranslate"><span class="pre">x</span></code> for that dimension. Column <code class="docutils literal notranslate"><span class="pre">splits[:,</span> <span class="pre">i]</span></code>
contains splitting points only up to <code class="docutils literal notranslate"><span class="pre">length[i]</span></code>, while afterward
it is filled with a very large value.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<img alt="_images/kernelsref-BART.png" src="_images/kernelsref-BART.png" />
<img alt="_images/kernelsref-BART-samples.png" src="_images/kernelsref-BART-samples.png" />
<dl class="py class">
<dt class="sig sig-object py" id="lsqfitgp.BagOfWords">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">BagOfWords</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Gattocrucco/lsqfitgp/blob/master/src/lsqfitgp/_kernels/_basic.py#L285-L314"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lsqfitgp.BagOfWords" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Bag of words kernel.</p>
<div class="math notranslate nohighlight">
\[\begin{split}k(x, y) &amp;= \sum_{w \in \text{words}} c_w(x) c_w(y), \\
c_w(x) &amp;= \text{number of times word $w$ appears in $x$}\end{split}\]</div>
<p>The words are defined as non-empty substrings delimited by spaces or one of
the following punctuation characters: ! Â« Â» â â â â â / ( ) â ? Â¡ Â¿ â â &lt; &gt;
, ; . : - â â.</p>
<p>Reference: Rasmussen and Williams (2006, p. 100).</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="lsqfitgp.Bessel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">Bessel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">r2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nu</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Gattocrucco/lsqfitgp/blob/master/src/lsqfitgp/_kernels/_matern.py#L111-L134"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lsqfitgp.Bessel" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Bessel kernel.</p>
<div class="math notranslate nohighlight">
\[k(r) = \Gamma(\nu + 1) 2^\nu (sr)^{-\nu} J_{\nu}(sr),
\quad s = 2 + \nu / 2,
\quad \nu \ge 0,\]</div>
<p>where <span class="math notranslate nohighlight">\(s\)</span> is a crude estimate of the half width at half maximum of
<span class="math notranslate nohighlight">\(J_\nu\)</span>. Can be used in up to <span class="math notranslate nohighlight">\(2(\lfloor\nu\rfloor + 1)\)</span>
dimensions and derived up to <span class="math notranslate nohighlight">\(\lfloor\nu/2\rfloor\)</span> times.</p>
<p>Reference: Rasmussen and Williams (2006, p. 89).</p>
</dd></dl>

<img alt="_images/kernelsref-Bessel.png" src="_images/kernelsref-Bessel.png" />
<img alt="_images/kernelsref-Bessel-samples.png" src="_images/kernelsref-Bessel-samples.png" />
<dl class="py class">
<dt class="sig sig-object py" id="lsqfitgp.BrownianBridge">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">BrownianBridge</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Gattocrucco/lsqfitgp/blob/master/src/lsqfitgp/_kernels/_randomwalk.py#L141-L162"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lsqfitgp.BrownianBridge" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Brownian bridge kernel.</p>
<div class="math notranslate nohighlight">
\[k(x, y) = \min(x, y) - xy,
\quad x, y \in [0, 1]\]</div>
<p>It is a Wiener process conditioned on being zero at x = 1.</p>
</dd></dl>

<img alt="_images/kernelsref-BrownianBridge.png" src="_images/kernelsref-BrownianBridge.png" />
<img alt="_images/kernelsref-BrownianBridge-samples.png" src="_images/kernelsref-BrownianBridge-samples.png" />
<dl class="py class">
<dt class="sig sig-object py" id="lsqfitgp.Categorical">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">Categorical</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cov</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Gattocrucco/lsqfitgp/blob/master/src/lsqfitgp/_kernels/_basic.py#L218-L239"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lsqfitgp.Categorical" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Categorical kernel.</p>
<div class="math notranslate nohighlight">
\[k(x, y) = \texttt{cov}[x, y]\]</div>
<p>A kernel over integers from 0 to N-1. The parameter <code class="docutils literal notranslate"><span class="pre">cov</span></code> is the covariance
matrix of the values.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="lsqfitgp.Cauchy">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">Cauchy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">r2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Gattocrucco/lsqfitgp/blob/master/src/lsqfitgp/_kernels/_basic.py#L334-L365"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lsqfitgp.Cauchy" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Generalized Cauchy kernel.</p>
<div class="math notranslate nohighlight">
\[k(r) = \left(1 + \frac{r^\alpha}{\beta} \right)^{-\beta/\alpha},
\quad \alpha \in (0, 2], \beta &gt; 0.\]</div>
<p>In the geostatistics literature, the case <span class="math notranslate nohighlight">\(\alpha=2\)</span> and
<span class="math notranslate nohighlight">\(\beta=2\)</span> (default) is known as the Cauchy kernel. In the machine
learning literature, the case <span class="math notranslate nohighlight">\(\alpha=2\)</span> (for any <span class="math notranslate nohighlight">\(\beta\)</span>) is
known as the rational quadratic kernel. For <span class="math notranslate nohighlight">\(\beta\to\infty\)</span> it is
equivalent to <code class="docutils literal notranslate"><span class="pre">GammaExp(gamma=alpha,</span> <span class="pre">scale=alpha</span> <span class="pre">**</span> <span class="pre">(1/alpha))</span></code>, while
for <span class="math notranslate nohighlight">\(\beta\to 0\)</span> to <code class="docutils literal notranslate"><span class="pre">Constant</span></code>. It is smooth only for
<span class="math notranslate nohighlight">\(\alpha=2\)</span>.</p>
<p>References: Gneiting and Schlather (2004, p. 273), Rasmussen and Williams
(2006, p. 86).</p>
</dd></dl>

<img alt="_images/kernelsref-Cauchy.png" src="_images/kernelsref-Cauchy.png" />
<img alt="_images/kernelsref-Cauchy-samples.png" src="_images/kernelsref-Cauchy-samples.png" />
<dl class="py class">
<dt class="sig sig-object py" id="lsqfitgp.CausalExpQuad">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">CausalExpQuad</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">r</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Gattocrucco/lsqfitgp/blob/master/src/lsqfitgp/_kernels/_basic.py#L370-L384"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lsqfitgp.CausalExpQuad" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Causal exponential quadratic kernel.</p>
<div class="math notranslate nohighlight">
\[k(r) = \big(1 - \operatorname{erf}(\alpha r/4)\big)
\exp\left(-\frac12 r^2 \right)\]</div>
<p>From <a class="reference external" href="https://github.com/wesselb/mlkernels">https://github.com/wesselb/mlkernels</a>.</p>
</dd></dl>

<img alt="_images/kernelsref-CausalExpQuad.png" src="_images/kernelsref-CausalExpQuad.png" />
<img alt="_images/kernelsref-CausalExpQuad-samples.png" src="_images/kernelsref-CausalExpQuad-samples.png" />
<dl class="py class">
<dt class="sig sig-object py" id="lsqfitgp.Celerite">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">Celerite</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">delta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Gattocrucco/lsqfitgp/blob/master/src/lsqfitgp/_kernels/_celerite.py#L34-L55"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lsqfitgp.Celerite" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Celerite kernel.</p>
<div class="math notranslate nohighlight">
\[k(\Delta) = \exp(-\gamma|\Delta|)
\big( \cos(\Delta) + B \sin(|\Delta|) \big)\]</div>
<p>This is the covariance function of an AR(2) process with complex roots. The
parameters must satisfy the condition <span class="math notranslate nohighlight">\(|B| \le \gamma\)</span>. For
<span class="math notranslate nohighlight">\(B = \gamma\)</span> it is equivalent to the <a class="reference internal" href="#lsqfitgp.Harmonic" title="lsqfitgp.Harmonic"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Harmonic</span></code></a> kernel with
<span class="math notranslate nohighlight">\(\eta Q = 1/B, Q &gt; 1\)</span>, and it is derivable.</p>
<p>Reference: Daniel Foreman-Mackey, Eric Agol, Sivaram Ambikasaran, and Ruth
Angus: <em>Fast and Scalable Gaussian Process Modeling With Applications To
Astronomical Time Series</em>.</p>
</dd></dl>

<img alt="_images/kernelsref-Celerite.png" src="_images/kernelsref-Celerite.png" />
<img alt="_images/kernelsref-Celerite-samples.png" src="_images/kernelsref-Celerite-samples.png" />
<dl class="py class">
<dt class="sig sig-object py" id="lsqfitgp.Circular">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">Circular</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">delta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Gattocrucco/lsqfitgp/blob/master/src/lsqfitgp/_kernels/_wendland.py#L108-L128"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lsqfitgp.Circular" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Circular kernel.</p>
<div class="math notranslate nohighlight">
\[\begin{split}k(x, y) &amp;= W_c(d_{\text{geo}}(x, y)), \\
W_c(t) &amp;= \left(1 + \tau\frac tc\right)
    \left(1 - \frac tc\right)^\tau_+,
\quad c \in (0, 1/2], \tau \ge 4, \\
d_{\text{geo}}(x, y) &amp;= \arccos\cos(2\pi(x-y)).\end{split}\]</div>
<p>It is a stationary periodic kernel with period 1.</p>
<p>Reference: Padonou and Roustant (2016).</p>
</dd></dl>

<img alt="_images/kernelsref-Circular.png" src="_images/kernelsref-Circular.png" />
<img alt="_images/kernelsref-Circular-samples.png" src="_images/kernelsref-Circular-samples.png" />
<dl class="py class">
<dt class="sig sig-object py" id="lsqfitgp.Color">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">Color</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">delta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Gattocrucco/lsqfitgp/blob/master/src/lsqfitgp/_kernels/_spectral.py#L76-L151"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lsqfitgp.Color" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Colored noise kernel.</p>
<div class="math notranslate nohighlight">
\[\begin{split}k(\Delta) &amp;= (n-1) \Re E_n(-i\Delta) = \\
&amp;= (n-1) \int_1^\infty \mathrm d\omega
\frac{\cos(\omega\Delta)}{\omega^n},
\quad n \in \mathbb N, n \ge 2.\end{split}\]</div>
<p>A process with power spectrum <span class="math notranslate nohighlight">\(1/\omega^n\)</span> truncated below
<span class="math notranslate nohighlight">\(\omega = 1\)</span>. <span class="math notranslate nohighlight">\(\omega\)</span> is the angular frequency
<span class="math notranslate nohighlight">\(\omega = 2\pi f\)</span>. Derivable <span class="math notranslate nohighlight">\(\lfloor n/2 \rfloor - 1\)</span>
times.</p>
</dd></dl>

<img alt="_images/kernelsref-Color.png" src="_images/kernelsref-Color.png" />
<img alt="_images/kernelsref-Color-samples.png" src="_images/kernelsref-Color-samples.png" />
<dl class="py class">
<dt class="sig sig-object py" id="lsqfitgp.Constant">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">Constant</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Gattocrucco/lsqfitgp/blob/master/src/lsqfitgp/_kernels/_basic.py#L34-L46"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lsqfitgp.Constant" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Constant kernel.</p>
<div class="math notranslate nohighlight">
\[k(x, y) = 1\]</div>
<p>This means that all points are completely correlated, thus it is equivalent
to fitting with a horizontal line. This can be seen also by observing that
1 = 1 x 1.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="lsqfitgp.Cos">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">Cos</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">delta</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Gattocrucco/lsqfitgp/blob/master/src/lsqfitgp/_kernels/_spectral.py#L25-L39"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lsqfitgp.Cos" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Cosine kernel.</p>
<div class="math notranslate nohighlight">
\[k(\Delta) = \cos(\Delta)
= \cos x \cos y + \sin x \sin y\]</div>
<p>Samples from this kernel are harmonic functions. It can be multiplied with
another kernel to introduce anticorrelations.</p>
</dd></dl>

<img alt="_images/kernelsref-Cos.png" src="_images/kernelsref-Cos.png" />
<img alt="_images/kernelsref-Cos-samples.png" src="_images/kernelsref-Cos-samples.png" />
<dl class="py class">
<dt class="sig sig-object py" id="lsqfitgp.Decaying">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">Decaying</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Gattocrucco/lsqfitgp/blob/master/src/lsqfitgp/_kernels/_basic.py#L386-L404"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lsqfitgp.Decaying" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Decaying kernel.</p>
<div class="math notranslate nohighlight">
\[k(x, y) =
\frac{1}{(1 + x + y)^\alpha},
\quad x, y, \alpha \ge 0\]</div>
<p>Reference: Swersky, Snoek and Adams (2014).</p>
</dd></dl>

<img alt="_images/kernelsref-Decaying.png" src="_images/kernelsref-Decaying.png" />
<img alt="_images/kernelsref-Decaying-samples.png" src="_images/kernelsref-Decaying-samples.png" />
<dl class="py class">
<dt class="sig sig-object py" id="lsqfitgp.ExpQuad">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">ExpQuad</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">r2</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Gattocrucco/lsqfitgp/blob/master/src/lsqfitgp/_kernels/_basic.py#L62-L76"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lsqfitgp.ExpQuad" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Exponential quadratic kernel.</p>
<div class="math notranslate nohighlight">
\[k(r) = \exp \left( -\frac 12 r^2 \right)\]</div>
<p>It is smooth and has a strict typical lengthscale, i.e., oscillations are
strongly suppressed under a certain wavelength, and correlations are
strongly suppressed over a certain distance.</p>
<p>Reference: Rasmussen and Williams (2006, p. 83).</p>
</dd></dl>

<img alt="_images/kernelsref-ExpQuad.png" src="_images/kernelsref-ExpQuad.png" />
<img alt="_images/kernelsref-ExpQuad-samples.png" src="_images/kernelsref-ExpQuad-samples.png" />
<dl class="py class">
<dt class="sig sig-object py" id="lsqfitgp.Expon">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">Expon</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">delta</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Gattocrucco/lsqfitgp/blob/master/src/lsqfitgp/_kernels/_basic.py#L264-L281"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lsqfitgp.Expon" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Exponential kernel.</p>
<div class="math notranslate nohighlight">
\[k(\Delta) = \exp(-|\Delta|)\]</div>
<p>In 1D it is equivalent to the MatÃ©rn 1/2 kernel, however in more dimensions
it acts separately while the MatÃ©rn kernel is isotropic.</p>
<p>Reference: Rasmussen and Williams (2006, p. 85).</p>
</dd></dl>

<img alt="_images/kernelsref-Expon.png" src="_images/kernelsref-Expon.png" />
<img alt="_images/kernelsref-Expon-samples.png" src="_images/kernelsref-Expon-samples.png" />
<dl class="py class">
<dt class="sig sig-object py" id="lsqfitgp.FracBrownian">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">FracBrownian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">K</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Gattocrucco/lsqfitgp/blob/master/src/lsqfitgp/_kernels/_randomwalk.py#L48-L72"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lsqfitgp.FracBrownian" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Bifractional Brownian motion kernel.</p>
<div class="math notranslate nohighlight">
\[k(x, y) = \frac 1{2^K} \big(
    (|x|^{2H} + |y|^{2H})^K - |x-y|^{2HK}
\big), \quad H, K \in (0, 1]\]</div>
<p>For <span class="math notranslate nohighlight">\(H = 1/2\)</span> (default) it is the Wiener kernel. For <span class="math notranslate nohighlight">\(H \in (0, 1/2)\)</span> the
increments are anticorrelated (strong oscillation), for <span class="math notranslate nohighlight">\(H \in (1/2, 1]\)</span>
the increments are correlated (tends to keep a slope).</p>
<p>Reference: HoudrÃ© and Villa (2003).</p>
</dd></dl>

<img alt="_images/kernelsref-FracBrownian.png" src="_images/kernelsref-FracBrownian.png" />
<img alt="_images/kernelsref-FracBrownian-samples.png" src="_images/kernelsref-FracBrownian-samples.png" />
<dl class="py class">
<dt class="sig sig-object py" id="lsqfitgp.GammaExp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">GammaExp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">r2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Gattocrucco/lsqfitgp/blob/master/src/lsqfitgp/_kernels/_basic.py#L95-L125"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lsqfitgp.GammaExp" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Gamma exponential kernel.</p>
<div class="math notranslate nohighlight">
\[k(r) = \exp(-r^\gamma), \quad
\gamma \in (0, 2]\]</div>
<p>For <span class="math notranslate nohighlight">\(\gamma = 2\)</span> it is the squared exponential kernel, for
<span class="math notranslate nohighlight">\(\gamma = 1\)</span> (default) it is the MatÃ©rn 1/2 kernel, for
<span class="math notranslate nohighlight">\(\gamma \to 0\)</span> it tends to white noise plus a constant. The process
is differentiable only for <span class="math notranslate nohighlight">\(\gamma = 2\)</span>, however as <span class="math notranslate nohighlight">\(\gamma\)</span>
gets closer to 2 the variance of the non-derivable component goes to zero.</p>
<p>Reference: Rasmussen and Williams (2006, p. 86).</p>
</dd></dl>

<img alt="_images/kernelsref-GammaExp.png" src="_images/kernelsref-GammaExp.png" />
<img alt="_images/kernelsref-GammaExp-samples.png" src="_images/kernelsref-GammaExp-samples.png" />
<dl class="py class">
<dt class="sig sig-object py" id="lsqfitgp.Gibbs">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">Gibbs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scalefun=&lt;function</span> <span class="pre">&lt;lambda&gt;</span> <span class="pre">at</span> <span class="pre">0x130d416c0&gt;</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Gattocrucco/lsqfitgp/blob/master/src/lsqfitgp/_kernels/_basic.py#L164-L193"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lsqfitgp.Gibbs" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Gibbs kernel.</p>
<div class="math notranslate nohighlight">
\[k(x, y) = \sqrt{ \frac {2 s(x) s(y)} {s(x)^2 + s(y)^2} }
\exp \left( -\frac {(x - y)^2} {s(x)^2 + s(y)^2} \right),
\quad s = \texttt{scalefun}.\]</div>
<p>Kernel which in some sense is like a Gaussian kernel where the scale
changes at every point. The scale is computed by the parameter <code class="xref py py-obj docutils literal notranslate"><span class="pre">scalefun</span></code>
which must be a callable taking the x array and returning a scale for each
point. By default <code class="docutils literal notranslate"><span class="pre">scalefun</span></code> returns 1 so it is a Gaussian kernel.</p>
<p>Consider that the default parameter <code class="docutils literal notranslate"><span class="pre">scale</span></code> acts before <code class="docutils literal notranslate"><span class="pre">scalefun</span></code>, so
for example if <code class="docutils literal notranslate"><span class="pre">scalefun(x)</span> <span class="pre">=</span> <span class="pre">x</span></code> then <code class="docutils literal notranslate"><span class="pre">scale</span></code> has no effect. You should
include all rescalings in <code class="docutils literal notranslate"><span class="pre">scalefun</span></code> to avoid surprises.</p>
<p>Reference: Rasmussen and Williams (2006, p. 93).</p>
</dd></dl>

<img alt="_images/kernelsref-Gibbs.png" src="_images/kernelsref-Gibbs.png" />
<img alt="_images/kernelsref-Gibbs-samples.png" src="_images/kernelsref-Gibbs-samples.png" />
<dl class="py class">
<dt class="sig sig-object py" id="lsqfitgp.Harmonic">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">Harmonic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">delta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Q</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Gattocrucco/lsqfitgp/blob/master/src/lsqfitgp/_kernels/_celerite.py#L57-L126"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lsqfitgp.Harmonic" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Damped stochastically driven harmonic oscillator kernel.</p>
<div class="math notranslate nohighlight">
\[\begin{split}k(\Delta) =
\exp\left( -\frac {|\Delta|} {Q} \right)
\begin{cases}
    \cosh(\eta\Delta) + \sinh(\eta|\Delta|) / (\eta Q)
    &amp; 0 &lt; Q &lt; 1 \\
    1 + |\Delta| &amp; Q = 1 \\
    \cos(\eta\Delta) + \sin(\eta|\Delta|) / (\eta Q)
    &amp; Q &gt; 1,
\end{cases}\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\eta = \sqrt{|1 - 1/Q^2|}\)</span>.</p>
<p>The process is the solution to the stochastic differential equation</p>
<div class="math notranslate nohighlight">
\[f''(x) + 2/Q f'(x) + f(x) = w(x),\]</div>
<p>where <span class="math notranslate nohighlight">\(w\)</span> is white noise.</p>
<p>The parameter <span class="math notranslate nohighlight">\(Q\)</span> is the quality factor, i.e., the ratio between the energy
stored in the oscillator and the energy lost in each cycle due to damping.
The angular frequency is 1, i.e., the period is 2Ï. The process is derivable
one time.</p>
<p>In 1D, for <span class="math notranslate nohighlight">\(Q = 1\)</span> (default) and <code class="docutils literal notranslate"><span class="pre">scale=sqrt(1/3)</span></code>, it is the MatÃ©rn 3/2
kernel.</p>
<p>Reference: Daniel Foreman-Mackey, Eric Agol, Sivaram Ambikasaran, and Ruth
Angus: <em>Fast and Scalable Gaussian Process Modeling With Applications To
Astronomical Time Series</em>.</p>
</dd></dl>

<img alt="_images/kernelsref-Harmonic.png" src="_images/kernelsref-Harmonic.png" />
<img alt="_images/kernelsref-Harmonic-samples.png" src="_images/kernelsref-Harmonic-samples.png" />
<dl class="py class">
<dt class="sig sig-object py" id="lsqfitgp.HoleEffect">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">HoleEffect</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">delta</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Gattocrucco/lsqfitgp/blob/master/src/lsqfitgp/_kernels/_basic.py#L318-L329"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lsqfitgp.HoleEffect" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Hole effect kernel.</p>
<div class="math notranslate nohighlight">
\[k(\Delta) = (1 - \Delta) \exp(-\Delta)\]</div>
<p>Reference: Dietrich and Newsam (1997, p. 1096).</p>
</dd></dl>

<img alt="_images/kernelsref-HoleEffect.png" src="_images/kernelsref-HoleEffect.png" />
<img alt="_images/kernelsref-HoleEffect-samples.png" src="_images/kernelsref-HoleEffect-samples.png" />
<dl class="py class">
<dt class="sig sig-object py" id="lsqfitgp.Linear">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">Linear</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Gattocrucco/lsqfitgp/blob/master/src/lsqfitgp/_kernels/_basic.py#L81-L93"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lsqfitgp.Linear" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Dot product kernel.</p>
<div class="math notranslate nohighlight">
\[k(x, y) = x \cdot y = \sum_i x_i y_i\]</div>
<p>In 1D it is equivalent to fitting with a line passing by the origin.</p>
<p>Reference: Rasmussen and Williams (2006, p. 89).</p>
</dd></dl>

<img alt="_images/kernelsref-Linear.png" src="_images/kernelsref-Linear.png" />
<img alt="_images/kernelsref-Linear-samples.png" src="_images/kernelsref-Linear-samples.png" />
<dl class="py class">
<dt class="sig sig-object py" id="lsqfitgp.Log">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">Log</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">r</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Gattocrucco/lsqfitgp/blob/master/src/lsqfitgp/_kernels/_basic.py#L406-L416"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lsqfitgp.Log" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Log kernel.</p>
<div class="math notranslate nohighlight">
\[k(r) = \log(1 + r) / r\]</div>
<p>From <a class="reference external" href="https://github.com/wesselb/mlkernels">https://github.com/wesselb/mlkernels</a>.</p>
</dd></dl>

<img alt="_images/kernelsref-Log.png" src="_images/kernelsref-Log.png" />
<img alt="_images/kernelsref-Log-samples.png" src="_images/kernelsref-Log-samples.png" />
<dl class="py class">
<dt class="sig sig-object py" id="lsqfitgp.MA">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">MA</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">delta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Gattocrucco/lsqfitgp/blob/master/src/lsqfitgp/_kernels/_arma.py#L31-L67"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lsqfitgp.MA" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Discrete moving average kernel.</p>
<div class="math notranslate nohighlight">
\[k(\Delta) = \sum_{k=|\Delta|}^{n-1} w_k w_{k-|\Delta|},
\quad \mathbf w = (w_0, \ldots, w_{n-1}).\]</div>
<p>The inputs must be integers. It is the autocovariance function of a moving
average with weights <span class="math notranslate nohighlight">\(\mathbf w\)</span> applied to white noise:</p>
<div class="math notranslate nohighlight">
\[\begin{split}k(i, j) &amp;= \operatorname{Cov}[y_i, y_j], \\
y_i &amp;= \sum_{k=0}^{n-1} w_k \epsilon_{i-k}, \\
\operatorname{Cov}[\epsilon_i,\epsilon_j] &amp;= \delta_{ij}.\end{split}\]</div>
<p>If <code class="docutils literal notranslate"><span class="pre">norm=True</span></code>, the variance is normalized to 1, which amounts to
normalizing <span class="math notranslate nohighlight">\(\mathbf w\)</span> to unit length.</p>
</dd></dl>

<img alt="_images/kernelsref-MA.png" src="_images/kernelsref-MA.png" />
<img alt="_images/kernelsref-MA-samples.png" src="_images/kernelsref-MA-samples.png" />
<dl class="py class">
<dt class="sig sig-object py" id="lsqfitgp.Matern">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">Matern</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">r2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nu</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Gattocrucco/lsqfitgp/blob/master/src/lsqfitgp/_kernels/_matern.py#L56-L86"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lsqfitgp.Matern" title="Permalink to this definition">Â¶</a></dt>
<dd><p>MatÃ©rn kernel of real order.</p>
<div class="math notranslate nohighlight">
\[k(r) = \frac {2^{1-\nu}} {\Gamma(\nu)} x^\nu K_\nu(x),
\quad \nu \ge 0,
\quad x = \sqrt{2\nu} r\]</div>
<p>The process is <span class="math notranslate nohighlight">\(\lceil\nu\rceil-1\)</span> times derivable: so for
<span class="math notranslate nohighlight">\(0 \le \nu \le 1\)</span> it is not derivable, for <span class="math notranslate nohighlight">\(1 &lt; \nu \le 2\)</span>
it is derivable but has not a second derivative, etc. The highest
derivative is (Lipschitz) continuous iff <span class="math notranslate nohighlight">\(\nu\bmod 1 \ge 1/2\)</span>.</p>
<p>Reference: Rasmussen and Williams (2006, p. 84).</p>
</dd></dl>

<img alt="_images/kernelsref-Matern.png" src="_images/kernelsref-Matern.png" />
<img alt="_images/kernelsref-Matern-samples.png" src="_images/kernelsref-Matern-samples.png" />
<dl class="py class">
<dt class="sig sig-object py" id="lsqfitgp.Maternp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">Maternp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">r2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Gattocrucco/lsqfitgp/blob/master/src/lsqfitgp/_kernels/_matern.py#L29-L50"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lsqfitgp.Maternp" title="Permalink to this definition">Â¶</a></dt>
<dd><p>MatÃ©rn kernel of half-integer order.</p>
<div class="math notranslate nohighlight">
\[\begin{split}k(r) &amp;= \frac {2^{1-\nu}} {\Gamma(\nu)} x^\nu K_\nu(x) = \\
&amp;= \exp(-x) \frac{p!}{(2p)!}
\sum_{i=0}^p \frac{(p+i)!}{i!(p-i)!} (2x)^{p-i} \\
\nu &amp;= p + 1/2,
p \in \mathbb N,
x = \sqrt{2\nu} r\end{split}\]</div>
<p>The degree of derivability is <span class="math notranslate nohighlight">\(p\)</span>.</p>
<p>Reference: Rasmussen and Williams (2006, p. 85).</p>
</dd></dl>

<img alt="_images/kernelsref-Maternp.png" src="_images/kernelsref-Maternp.png" />
<img alt="_images/kernelsref-Maternp-samples.png" src="_images/kernelsref-Maternp-samples.png" />
<dl class="py class">
<dt class="sig sig-object py" id="lsqfitgp.NNKernel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">NNKernel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Gattocrucco/lsqfitgp/blob/master/src/lsqfitgp/_kernels/_basic.py#L127-L162"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lsqfitgp.NNKernel" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Neural network kernel.</p>
<div class="math notranslate nohighlight">
\[k(x, y) = \frac 2 \pi
\arcsin \left( \frac
{
    2 (q + x \cdot y)
}{
    (1 + 2 (q + x \cdot x))
    (1 + 2 (q + y \cdot y))
}
\right),
\quad q = \texttt{sigma0}^2\]</div>
<p>Kernel which is equivalent to a neural network with one infinite hidden
layer with Gaussian priors on the weights and error function response. In
other words, you can think of the process as a superposition of sigmoids
where <code class="docutils literal notranslate"><span class="pre">sigma0</span></code> sets the dispersion of the centers of the sigmoids.</p>
<p>Reference: Rasmussen and Williams (2006, p. 90).</p>
</dd></dl>

<img alt="_images/kernelsref-NNKernel.png" src="_images/kernelsref-NNKernel.png" />
<img alt="_images/kernelsref-NNKernel-samples.png" src="_images/kernelsref-NNKernel-samples.png" />
<dl class="py class">
<dt class="sig sig-object py" id="lsqfitgp.OrnsteinUhlenbeck">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">OrnsteinUhlenbeck</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Gattocrucco/lsqfitgp/blob/master/src/lsqfitgp/_kernels/_randomwalk.py#L118-L139"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lsqfitgp.OrnsteinUhlenbeck" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Ornstein-Uhlenbeck process kernel.</p>
<div class="math notranslate nohighlight">
\[k(x, y) = \exp(-|x - y|) - \exp(-(x + y)),
\quad x, y \ge 0\]</div>
<p>It is a random walk plus a negative feedback term that keeps the
asymptotical variance constant. It is asymptotically stationary; often the
name âOrnstein-Uhlenbeckâ is given to the stationary part only, which here
is provided as <a class="reference internal" href="#lsqfitgp.Expon" title="lsqfitgp.Expon"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Expon</span></code></a>.</p>
</dd></dl>

<img alt="_images/kernelsref-OrnsteinUhlenbeck.png" src="_images/kernelsref-OrnsteinUhlenbeck.png" />
<img alt="_images/kernelsref-OrnsteinUhlenbeck-samples.png" src="_images/kernelsref-OrnsteinUhlenbeck-samples.png" />
<dl class="py class">
<dt class="sig sig-object py" id="lsqfitgp.Periodic">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">Periodic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">delta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">outerscale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Gattocrucco/lsqfitgp/blob/master/src/lsqfitgp/_kernels/_basic.py#L195-L216"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lsqfitgp.Periodic" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Periodic Gaussian kernel.</p>
<div class="math notranslate nohighlight">
\[k(\Delta) = \exp \left(
-2 \left(
\frac {\sin(\Delta / 2)} {\texttt{outerscale}}
\right)^2
\right)\]</div>
<p>A Gaussian kernel over a transformed periodic space. It represents a
periodic process. The usual <code class="docutils literal notranslate"><span class="pre">scale</span></code> parameter sets the period, with the
default <code class="docutils literal notranslate"><span class="pre">scale=1</span></code> giving a period of 2Ï, while the <code class="docutils literal notranslate"><span class="pre">outerscale</span></code> parameter
sets the length scale of the correlations.</p>
<p>Reference: Rasmussen and Williams (2006, p. 92).</p>
</dd></dl>

<img alt="_images/kernelsref-Periodic.png" src="_images/kernelsref-Periodic.png" />
<img alt="_images/kernelsref-Periodic-samples.png" src="_images/kernelsref-Periodic-samples.png" />
<dl class="py class">
<dt class="sig sig-object py" id="lsqfitgp.Pink">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">Pink</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">delta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dw</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Gattocrucco/lsqfitgp/blob/master/src/lsqfitgp/_kernels/_spectral.py#L42-L71"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lsqfitgp.Pink" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Pink noise kernel.</p>
<div class="math notranslate nohighlight">
\[\begin{split}k(\Delta) &amp;= \frac 1 {\log(1 + \delta\omega)}
\int_1^{1+\delta\omega} \mathrm d\omega
\frac{\cos(\omega\Delta)}\omega = \\
&amp;= \frac {     \operatorname{Ci}(\Delta (1 + \delta\omega))
                - \operatorname{Ci}(\Delta)                   }
{\log(1 + \delta\omega)}\end{split}\]</div>
<p>A process with power spectrum <span class="math notranslate nohighlight">\(1/\omega\)</span> truncated between 1 and
<span class="math notranslate nohighlight">\(1 + \delta\omega\)</span>. <span class="math notranslate nohighlight">\(\omega\)</span> is the angular frequency
<span class="math notranslate nohighlight">\(\omega = 2\pi f\)</span>. In the limit <span class="math notranslate nohighlight">\(\delta\omega\to\infty\)</span>
it becomes white noise. Derivable one time.</p>
</dd></dl>

<img alt="_images/kernelsref-Pink.png" src="_images/kernelsref-Pink.png" />
<img alt="_images/kernelsref-Pink-samples.png" src="_images/kernelsref-Pink-samples.png" />
<dl class="py class">
<dt class="sig sig-object py" id="lsqfitgp.Rescaling">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">Rescaling</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stdfun</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Gattocrucco/lsqfitgp/blob/master/src/lsqfitgp/_kernels/_basic.py#L241-L262"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lsqfitgp.Rescaling" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Outer product kernel.</p>
<div class="math notranslate nohighlight">
\[k(x, y) = \texttt{stdfun}(x) \texttt{stdfun}(y)\]</div>
<p>A totally correlated kernel with arbitrary variance. Parameter <code class="docutils literal notranslate"><span class="pre">stdfun</span></code>
must be a function that takes <code class="docutils literal notranslate"><span class="pre">x</span></code> or <code class="docutils literal notranslate"><span class="pre">y</span></code> and computes the standard
deviation at the point. It can yield negative values; points with the same
sign of <code class="docutils literal notranslate"><span class="pre">fun</span></code> will be totally correlated, points with different sign will
be totally anticorrelated. Use this kernel to modulate the variance of
other kernels. By default <code class="docutils literal notranslate"><span class="pre">stdfun</span></code> returns a constant, so it is equivalent
to <a class="reference internal" href="#lsqfitgp.Constant" title="lsqfitgp.Constant"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Constant</span></code></a>.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="lsqfitgp.Sinc">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">Sinc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">delta</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Gattocrucco/lsqfitgp/blob/master/src/lsqfitgp/_kernels/_spectral.py#L153-L166"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lsqfitgp.Sinc" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Sinc kernel.</p>
<div class="math notranslate nohighlight">
\[k(\Delta) = \operatorname{sinc}(\Delta) =
\frac{\sin(\pi\Delta)}{\pi\Delta}.\]</div>
<p>Reference: Tobar (2019).</p>
</dd></dl>

<img alt="_images/kernelsref-Sinc.png" src="_images/kernelsref-Sinc.png" />
<img alt="_images/kernelsref-Sinc-samples.png" src="_images/kernelsref-Sinc-samples.png" />
<dl class="py class">
<dt class="sig sig-object py" id="lsqfitgp.StationaryFracBrownian">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">StationaryFracBrownian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">delta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Gattocrucco/lsqfitgp/blob/master/src/lsqfitgp/_kernels/_randomwalk.py#L167-L186"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lsqfitgp.StationaryFracBrownian" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Stationary fractional Brownian motion kernel.</p>
<div class="math notranslate nohighlight">
\[k(\Delta) = \frac 12 (|\Delta+1|^{2H} + |\Delta-1|^{2H} - 2|\Delta|^{2H}),
\quad H \in (0, 1]\]</div>
<p>Reference: Gneiting and Schlather (2006, p. 272).</p>
</dd></dl>

<img alt="_images/kernelsref-StationaryFracBrownian.png" src="_images/kernelsref-StationaryFracBrownian.png" />
<img alt="_images/kernelsref-StationaryFracBrownian-samples.png" src="_images/kernelsref-StationaryFracBrownian-samples.png" />
<dl class="py class">
<dt class="sig sig-object py" id="lsqfitgp.Taylor">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">Taylor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Gattocrucco/lsqfitgp/blob/master/src/lsqfitgp/_kernels/_basic.py#L418-L442"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lsqfitgp.Taylor" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Exponential-like power series kernel.</p>
<div class="math notranslate nohighlight">
\[k(x, y) = \sum_{k=0}^\infty \frac {x^k}{k!} \frac {y^k}{k!}
= I_0(2 \sqrt{xy})\]</div>
<p>It is equivalent to fitting with a Taylor series expansion in zero with
independent priors on the coefficients k with mean zero and standard
deviation 1/k!.</p>
</dd></dl>

<img alt="_images/kernelsref-Taylor.png" src="_images/kernelsref-Taylor.png" />
<img alt="_images/kernelsref-Taylor-samples.png" src="_images/kernelsref-Taylor-samples.png" />
<dl class="py class">
<dt class="sig sig-object py" id="lsqfitgp.Wendland">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">Wendland</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">r</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Gattocrucco/lsqfitgp/blob/master/src/lsqfitgp/_kernels/_wendland.py#L32-L93"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lsqfitgp.Wendland" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Wendland kernel.</p>
<div class="math notranslate nohighlight">
\[\begin{split}k(r) &amp;= \frac1{B(2k+1,\nu)}
\int_r^\infty \mathrm du\, (u^2 - r^2)^k (1 - u)_+^{\nu-1}, \\
\quad k &amp;\in \mathbb N,\ \nu = k + \alpha,\ \alpha \ge 1.\end{split}\]</div>
<p>An isotropic kernel with finite support. The covariance is nonzero only
when the distance between the points is less than 1. Parameter <span class="math notranslate nohighlight">\(k \in \{0,
1, 2, 3\}\)</span> sets the differentiability, while the maximum dimensionality the
kernel can be used in is <span class="math notranslate nohighlight">\(\lfloor 2\alpha-1 \rfloor\)</span>. Default is
<span class="math notranslate nohighlight">\(k = 0\)</span> (non derivable), <span class="math notranslate nohighlight">\(\alpha = 1\)</span> (can be used only in
1D).</p>
<p>Reference: Gneiting (2002), Wendland (2004, p. 128), Rasmussen and Williams
(2006, p. 87), Porcu, Furrer and Nychka (2020, p. 4).</p>
</dd></dl>

<img alt="_images/kernelsref-Wendland.png" src="_images/kernelsref-Wendland.png" />
<img alt="_images/kernelsref-Wendland-samples.png" src="_images/kernelsref-Wendland-samples.png" />
<dl class="py class">
<dt class="sig sig-object py" id="lsqfitgp.White">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">White</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Gattocrucco/lsqfitgp/blob/master/src/lsqfitgp/_kernels/_basic.py#L48-L60"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lsqfitgp.White" title="Permalink to this definition">Â¶</a></dt>
<dd><p>White noise kernel.</p>
<div class="math notranslate nohighlight">
\[\begin{split}k(x, y) = \begin{cases}
    1 &amp; x = y     \\
    0 &amp; x \neq y
\end{cases}\end{split}\]</div>
</dd></dl>

<img alt="_images/kernelsref-White.png" src="_images/kernelsref-White.png" />
<img alt="_images/kernelsref-White-samples.png" src="_images/kernelsref-White-samples.png" />
<dl class="py class">
<dt class="sig sig-object py" id="lsqfitgp.Wiener">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">Wiener</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Gattocrucco/lsqfitgp/blob/master/src/lsqfitgp/_kernels/_randomwalk.py#L26-L41"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lsqfitgp.Wiener" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Wiener kernel.</p>
<div class="math notranslate nohighlight">
\[k(x, y) = \min(x, y), \quad x, y &gt; 0\]</div>
<p>A kernel representing a non-differentiable random walk starting at 0.</p>
<p>Reference: Rasmussen and Williams (2006, p. 94).</p>
</dd></dl>

<img alt="_images/kernelsref-Wiener.png" src="_images/kernelsref-Wiener.png" />
<img alt="_images/kernelsref-Wiener-samples.png" src="_images/kernelsref-Wiener-samples.png" />
<dl class="py class">
<dt class="sig sig-object py" id="lsqfitgp.WienerIntegral">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">WienerIntegral</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Gattocrucco/lsqfitgp/blob/master/src/lsqfitgp/_kernels/_randomwalk.py#L97-L116"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lsqfitgp.WienerIntegral" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Kernel for a process whose derivative is a Wiener process.</p>
<div class="math notranslate nohighlight">
\[k(x, y) = \frac 12 a^2 \left(b - \frac a3 \right),
\quad a = \min(x, y), b = \max(x, y)\]</div>
</dd></dl>

<img alt="_images/kernelsref-WienerIntegral.png" src="_images/kernelsref-WienerIntegral.png" />
<img alt="_images/kernelsref-WienerIntegral-samples.png" src="_images/kernelsref-WienerIntegral-samples.png" />
<dl class="py class">
<dt class="sig sig-object py" id="lsqfitgp.Zeta">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">Zeta</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">delta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nu</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Gattocrucco/lsqfitgp/blob/master/src/lsqfitgp/_kernels/_zeta.py#L31-L83"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lsqfitgp.Zeta" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Zeta kernel.</p>
<div class="math notranslate nohighlight">
\[\begin{split}k(\Delta)
&amp;= \frac{\Re F(\Delta, s)}{\zeta(s)} =
\qquad (s = 1 + 2 \nu, \quad \nu \ge 0) \\
&amp;= \frac1{\zeta(s)} \sum_{k=1}^\infty
\frac {\cos(2\pi k\Delta)} {k^s} = \\
&amp;= -(-1)^{s/2}
\frac {(2\pi)^s} {2s!}
\frac {\tilde B_s(\Delta)} {\zeta(s)}
\quad \text{for even integer $s$.}\end{split}\]</div>
<p>It is equivalent to fitting with a Fourier series of period 1 with
independent priors on the coefficients with mean zero and variance
<span class="math notranslate nohighlight">\(1/(\zeta(s)k^s)\)</span> for the <span class="math notranslate nohighlight">\(k\)</span>-th term. Analogously to
<a class="reference internal" href="#lsqfitgp.Matern" title="lsqfitgp.Matern"><code class="xref py py-class docutils literal notranslate"><span class="pre">Matern</span></code></a>, the process is <span class="math notranslate nohighlight">\(\lceil\nu\rceil - 1\)</span> times
derivable, and the highest derivative is continuous iff <span class="math notranslate nohighlight">\(\nu\bmod 1
\ge 1/2\)</span>.</p>
<p>Note that the <span class="math notranslate nohighlight">\(k = 0\)</span> term is not included in the summation, so the
mean of the process over one period is forced to be zero.</p>
<p>Reference: Petrillo (2022).</p>
<dl class="py method">
<dt class="sig sig-object py" id="lsqfitgp.Zeta.fourier">
<span class="sig-name descname"><span class="pre">fourier</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dox</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">doy</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/Gattocrucco/lsqfitgp/blob/master/src/lsqfitgp/_kernels/_zeta.py#L102-L135"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lsqfitgp.Zeta.fourier" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Compute the Fourier series of the kernel.</p>
<div class="math notranslate nohighlight">
\[\begin{split}h(k, y) = \begin{cases}
    \frac2T \int_0^T \mathrm dx\, k(x, y)
    \cos\left(\frac{2\pi}T \frac k2 x\right)
    &amp; \text{if $k$ is even} \\
    \frac2T \int_0^T \mathrm dx\, k(x, y)
    \sin\left(\frac{2\pi}T \frac{k+1}2 x\right)
    &amp; \text{if $k$ is odd}
\end{cases}\end{split}\]</div>
<p>The period <span class="math notranslate nohighlight">\(T\)</span> is implicit in the definition of the kernel.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dox, doy</strong><span class="classifier">bool</span></dt><dd><p>Specify if to compute the series w.r.t. x, y or both. If both are
False, this is a no-op.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>h</strong><span class="classifier">Kernel-like</span></dt><dd><p>A Kernel-like object computing the Fourier series. If dox and
doy are equal, it is a Kernel.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<img alt="_images/kernelsref-Zeta.png" src="_images/kernelsref-Zeta.png" />
<img alt="_images/kernelsref-Zeta-samples.png" src="_images/kernelsref-Zeta-samples.png" />
</section>
</section>


          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="reference.html" title="Previous document">Reference manual</a>
        </li>
        <li>
          <a href="kernel.html" title="Next document"><span class="section-number">2. </span>Generic kernel classes</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;2020-2023, Giacomo Petrillo.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="_sources/kernelsref.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>