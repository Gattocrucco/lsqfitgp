
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>1. Kernels reference &#8212; lsqfitgp 0.12 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="2. Generic kernel classes" href="kernel.html" />
    <link rel="prev" title="Reference manual" href="reference.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">lsqfitgp 0.12</a></h1>



<p class="blurb">A general purpose Gaussian process regression module</p>




<p>
<iframe src="https://ghbtns.com/github-btn.html?user=Gattocrucco&repo=lsqfitgp&type=star&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>





<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="userguide.html">User guide</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="reference.html">Reference manual</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">1. Kernels reference</a></li>
<li class="toctree-l2"><a class="reference internal" href="kernel.html">2. Generic kernel classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="kerneldec.html">3. Kernel decorators</a></li>
<li class="toctree-l2"><a class="reference internal" href="kernelop.html">4. Kernel operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="deriv.html">5. Derivative specification</a></li>
<li class="toctree-l2"><a class="reference internal" href="gp.html">6. Gaussian process class</a></li>
<li class="toctree-l2"><a class="reference internal" href="array.html">7. Structured arrays wrapping</a></li>
<li class="toctree-l2"><a class="reference internal" href="fit.html">8. Fitting</a></li>
<li class="toctree-l2"><a class="reference internal" href="raniter.html">9. Random sampling</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="examples.html">Examples</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
  <li><a href="reference.html">Reference manual</a><ul>
      <li>Previous: <a href="reference.html" title="previous chapter">Reference manual</a></li>
      <li>Next: <a href="kernel.html" title="next chapter"><span class="section-number">2. </span>Generic kernel classes</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
              <div class="related top">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="reference.html" title="Previous document">Reference manual</a>
        </li>
        <li>
          <a href="kernel.html" title="Next document"><span class="section-number">2. </span>Generic kernel classes</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          

          <div class="body" role="main">
            
  <section id="kernels-reference">
<span id="kernels"></span><h1><span class="section-number">1. </span>Kernels reference<a class="headerlink" href="#kernels-reference" title="Permalink to this heading">¶</a></h1>
<p>This is a list of all the specific kernels implemented in <a class="reference internal" href="index.html#module-lsqfitgp" title="lsqfitgp"><code class="xref py py-mod docutils literal notranslate"><span class="pre">lsqfitgp</span></code></a>.</p>
<p>Kernels are reported with a simplified signature where the positional arguments
are <cite>r</cite> or <cite>r2</cite> if the kernel is isotropic, <cite>delta</cite> if it is stationary, or
<cite>x</cite>, <cite>y</cite> for generic kernels, and with only the keyword arguments specific to
the kernel. All kernels also understand the general keyword arguments of
<a class="reference internal" href="kernel.html#lsqfitgp.Kernel" title="lsqfitgp.Kernel"><code class="xref py py-class docutils literal notranslate"><span class="pre">Kernel</span></code></a> (or their specific superclass), while there are no positional
arguments when instantiating the kernel and the call signature of instances is
always <cite>x</cite>, <cite>y</cite>.</p>
<p>Example: the kernel <a class="reference internal" href="#lsqfitgp.GammaExp" title="lsqfitgp.GammaExp"><code class="xref py py-class docutils literal notranslate"><span class="pre">GammaExp</span></code></a> is listed as <code class="docutils literal notranslate"><span class="pre">GammaExp(r,</span> <span class="pre">gamma=1)</span></code>.
This means you could use it this way:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">lsqfitgp</span> <span class="k">as</span> <span class="nn">lgp</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="n">kernel</span> <span class="o">=</span> <span class="n">lgp</span><span class="o">.</span><span class="n">GammaExp</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="mf">1.4</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
<span class="n">covmat</span> <span class="o">=</span> <span class="n">kernel</span><span class="p">(</span><span class="n">x</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:])</span>
</pre></div>
</div>
<p>On multidimensional input, isotropic kernels will compute the euclidean
distance. In general non-isotropic kernels will act separately on each
dimension, i.e., <span class="math notranslate nohighlight">\(k(x_1,y_1,x_2,y_2) = k(x_1,y_1) k(x_2,y_2)\)</span>, apart from
kernels defined in terms of the dot product.</p>
<p>For all isotropic and stationary (i.e., depending only on <span class="math notranslate nohighlight">\(x - y\)</span>)
kernels <span class="math notranslate nohighlight">\(k(x, x) = 1\)</span>, and the typical lengthscale is approximately 1 for
default values of the keyword parameters, apart from some specific cases like
<a class="reference internal" href="#lsqfitgp.Constant" title="lsqfitgp.Constant"><code class="xref py py-class docutils literal notranslate"><span class="pre">Constant</span></code></a>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Taking second or higher order derivatives might give problems with isotropic
kernels with signature parameter <cite>r</cite>, while those with <cite>r2</cite> won’t have any
issue.</p>
</div>
<section id="index">
<h2><span class="section-number">1.1. </span>Index<a class="headerlink" href="#index" title="Permalink to this heading">¶</a></h2>
<section id="isotropic-kernels">
<h3><span class="section-number">1.1.1. </span>Isotropic kernels<a class="headerlink" href="#isotropic-kernels" title="Permalink to this heading">¶</a></h3>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#lsqfitgp.Bessel" title="lsqfitgp.Bessel"><code class="xref py py-func docutils literal notranslate"><span class="pre">Bessel()</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.Cauchy" title="lsqfitgp.Cauchy"><code class="xref py py-func docutils literal notranslate"><span class="pre">Cauchy()</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.CausalExpQuad" title="lsqfitgp.CausalExpQuad"><code class="xref py py-func docutils literal notranslate"><span class="pre">CausalExpQuad()</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.Constant" title="lsqfitgp.Constant"><code class="xref py py-func docutils literal notranslate"><span class="pre">Constant()</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.ExpQuad" title="lsqfitgp.ExpQuad"><code class="xref py py-func docutils literal notranslate"><span class="pre">ExpQuad()</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.GammaExp" title="lsqfitgp.GammaExp"><code class="xref py py-func docutils literal notranslate"><span class="pre">GammaExp()</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.Log" title="lsqfitgp.Log"><code class="xref py py-func docutils literal notranslate"><span class="pre">Log()</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.Matern" title="lsqfitgp.Matern"><code class="xref py py-func docutils literal notranslate"><span class="pre">Matern()</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.Maternp" title="lsqfitgp.Maternp"><code class="xref py py-func docutils literal notranslate"><span class="pre">Maternp()</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.PPKernel" title="lsqfitgp.PPKernel"><code class="xref py py-func docutils literal notranslate"><span class="pre">PPKernel()</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.White" title="lsqfitgp.White"><code class="xref py py-func docutils literal notranslate"><span class="pre">White()</span></code></a></p></li>
</ul>
</div></blockquote>
</section>
<section id="stationary-kernels">
<h3><span class="section-number">1.1.2. </span>Stationary kernels<a class="headerlink" href="#stationary-kernels" title="Permalink to this heading">¶</a></h3>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#lsqfitgp.Celerite" title="lsqfitgp.Celerite"><code class="xref py py-func docutils literal notranslate"><span class="pre">Celerite()</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.Cos" title="lsqfitgp.Cos"><code class="xref py py-func docutils literal notranslate"><span class="pre">Cos()</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.Expon" title="lsqfitgp.Expon"><code class="xref py py-func docutils literal notranslate"><span class="pre">Expon()</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.Fourier" title="lsqfitgp.Fourier"><code class="xref py py-func docutils literal notranslate"><span class="pre">Fourier()</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.Harmonic" title="lsqfitgp.Harmonic"><code class="xref py py-func docutils literal notranslate"><span class="pre">Harmonic()</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.HoleEffect" title="lsqfitgp.HoleEffect"><code class="xref py py-func docutils literal notranslate"><span class="pre">HoleEffect()</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.Periodic" title="lsqfitgp.Periodic"><code class="xref py py-func docutils literal notranslate"><span class="pre">Periodic()</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.Pink" title="lsqfitgp.Pink"><code class="xref py py-func docutils literal notranslate"><span class="pre">Pink()</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.Sinc" title="lsqfitgp.Sinc"><code class="xref py py-func docutils literal notranslate"><span class="pre">Sinc()</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.StationaryFracBrownian" title="lsqfitgp.StationaryFracBrownian"><code class="xref py py-func docutils literal notranslate"><span class="pre">StationaryFracBrownian()</span></code></a></p></li>
</ul>
</div></blockquote>
</section>
<section id="other-kernels">
<h3><span class="section-number">1.1.3. </span>Other kernels<a class="headerlink" href="#other-kernels" title="Permalink to this heading">¶</a></h3>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#lsqfitgp.BagOfWords" title="lsqfitgp.BagOfWords"><code class="xref py py-func docutils literal notranslate"><span class="pre">BagOfWords()</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.BrownianBridge" title="lsqfitgp.BrownianBridge"><code class="xref py py-func docutils literal notranslate"><span class="pre">BrownianBridge()</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.Categorical" title="lsqfitgp.Categorical"><code class="xref py py-func docutils literal notranslate"><span class="pre">Categorical()</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.Decaying" title="lsqfitgp.Decaying"><code class="xref py py-func docutils literal notranslate"><span class="pre">Decaying()</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.FracBrownian" title="lsqfitgp.FracBrownian"><code class="xref py py-func docutils literal notranslate"><span class="pre">FracBrownian()</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.Gibbs" title="lsqfitgp.Gibbs"><code class="xref py py-func docutils literal notranslate"><span class="pre">Gibbs()</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.Linear" title="lsqfitgp.Linear"><code class="xref py py-func docutils literal notranslate"><span class="pre">Linear()</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.NNKernel" title="lsqfitgp.NNKernel"><code class="xref py py-func docutils literal notranslate"><span class="pre">NNKernel()</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.OrnsteinUhlenbeck" title="lsqfitgp.OrnsteinUhlenbeck"><code class="xref py py-func docutils literal notranslate"><span class="pre">OrnsteinUhlenbeck()</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.Rescaling" title="lsqfitgp.Rescaling"><code class="xref py py-func docutils literal notranslate"><span class="pre">Rescaling()</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.Taylor" title="lsqfitgp.Taylor"><code class="xref py py-func docutils literal notranslate"><span class="pre">Taylor()</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.Wiener" title="lsqfitgp.Wiener"><code class="xref py py-func docutils literal notranslate"><span class="pre">Wiener()</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.WienerIntegral" title="lsqfitgp.WienerIntegral"><code class="xref py py-func docutils literal notranslate"><span class="pre">WienerIntegral()</span></code></a></p></li>
</ul>
</div></blockquote>
</section>
</section>
<section id="documentation">
<h2><span class="section-number">1.2. </span>Documentation<a class="headerlink" href="#documentation" title="Permalink to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="lsqfitgp.BagOfWords">
<span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">BagOfWords</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfitgp.BagOfWords" title="Permalink to this definition">¶</a></dt>
<dd><p>Bag of words kernel.</p>
<div class="math notranslate nohighlight">
\[\begin{split}k(x, y) &amp;= \sum_{w \in \text{words}} c_w(x) c_w(y), \\
c_w(x) &amp;= \text{number of times word $w$ appears in $x$}\end{split}\]</div>
<p>The words are defined as non-empty substrings delimited by spaces or one of
the following punctuation characters: ! « » ” “ ” ‘ ’ / ( ) ‘ ? ¡ ¿ „ ‚ &lt; &gt;
, ; . : - – —.</p>
<p>Reference: Rasmussen and Williams (2006, p. 100).</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lsqfitgp.Bessel">
<span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">Bessel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">r2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nu</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfitgp.Bessel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bessel kernel.</p>
<div class="math notranslate nohighlight">
\[k(r) = \Gamma(\nu + 1) 2^\nu (sr)^{-\nu} J_{\nu}(sr),
\quad s = 2 + \nu / 2,\]</div>
<p>where <cite>s</cite> is a crude estimate of the half width at half maximum of
<span class="math notranslate nohighlight">\(J_\nu\)</span>. Can be used in up to <span class="math notranslate nohighlight">\(2(\lfloor\nu\rfloor + 1)\)</span>
dimensions and derived up to <span class="math notranslate nohighlight">\(\lfloor\nu/2\rfloor\)</span> times.</p>
<p>Reference: Rasmussen and Williams (2006, p. 89).</p>
</dd></dl>

<img alt="_images/kernelsref-Bessel.png" src="_images/kernelsref-Bessel.png" />
<img alt="_images/kernelsref-Bessel-samples.png" src="_images/kernelsref-Bessel-samples.png" />
<dl class="py function">
<dt class="sig sig-object py" id="lsqfitgp.BrownianBridge">
<span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">BrownianBridge</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfitgp.BrownianBridge" title="Permalink to this definition">¶</a></dt>
<dd><p>Brownian bridge kernel.</p>
<div class="math notranslate nohighlight">
\[k(x, y) = \min(x, y) - xy,
\quad x, y \in [0, 1]\]</div>
<p>It is a Wiener process conditioned on being zero at x = 1.</p>
</dd></dl>

<img alt="_images/kernelsref-BrownianBridge.png" src="_images/kernelsref-BrownianBridge.png" />
<img alt="_images/kernelsref-BrownianBridge-samples.png" src="_images/kernelsref-BrownianBridge-samples.png" />
<dl class="py function">
<dt class="sig sig-object py" id="lsqfitgp.Categorical">
<span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">Categorical</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cov</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfitgp.Categorical" title="Permalink to this definition">¶</a></dt>
<dd><p>Categorical kernel.</p>
<div class="math notranslate nohighlight">
\[k(x, y) = \texttt{cov}[x, y]\]</div>
<p>A kernel over integers from 0 to N-1. The parameter <cite>cov</cite> is the covariance
matrix of the values.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lsqfitgp.Cauchy">
<span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">Cauchy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">r2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfitgp.Cauchy" title="Permalink to this definition">¶</a></dt>
<dd><p>Generalized Cauchy kernel.</p>
<div class="math notranslate nohighlight">
\[k(r) = \left(1 + \frac{r^\alpha}{\beta} \right)^{-\beta/\alpha},
\quad \alpha \in (0, 2], \beta &gt; 0.\]</div>
<p>In the geostatistics literature, the case <span class="math notranslate nohighlight">\(\alpha=2\)</span> and
<span class="math notranslate nohighlight">\(\beta=2\)</span> (default) is known as the Cauchy kernel. In the machine
learning literature, the case <span class="math notranslate nohighlight">\(\alpha=2\)</span> (for any <span class="math notranslate nohighlight">\(\beta\)</span>) is
known as the rational quadratic kernel. For <span class="math notranslate nohighlight">\(\beta\to\infty\)</span> it is
equivalent to <code class="docutils literal notranslate"><span class="pre">GammaExp(gamma=alpha,</span> <span class="pre">scale=alpha</span> <span class="pre">**</span> <span class="pre">(1/alpha))</span></code>, while
for <span class="math notranslate nohighlight">\(\beta\to 0\)</span> to <code class="docutils literal notranslate"><span class="pre">Constant</span></code>. It is smooth only for
<span class="math notranslate nohighlight">\(\alpha=2\)</span>.</p>
<p>References: Gneiting and Schlather (2004, p. 273), Rasmussen and Williams
(2006, p. 86).</p>
</dd></dl>

<img alt="_images/kernelsref-Cauchy.png" src="_images/kernelsref-Cauchy.png" />
<img alt="_images/kernelsref-Cauchy-samples.png" src="_images/kernelsref-Cauchy-samples.png" />
<dl class="py function">
<dt class="sig sig-object py" id="lsqfitgp.CausalExpQuad">
<span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">CausalExpQuad</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">r</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfitgp.CausalExpQuad" title="Permalink to this definition">¶</a></dt>
<dd><p>Causal exponential quadratic kernel.</p>
<div class="math notranslate nohighlight">
\[k(r) = \big(1 - \operatorname{erf}(\alpha r/4)\big)
\exp\left(-\frac12 r^2 \right)\]</div>
<p>From <a class="reference external" href="https://github.com/wesselb/mlkernels">https://github.com/wesselb/mlkernels</a>.</p>
</dd></dl>

<img alt="_images/kernelsref-CausalExpQuad.png" src="_images/kernelsref-CausalExpQuad.png" />
<img alt="_images/kernelsref-CausalExpQuad-samples.png" src="_images/kernelsref-CausalExpQuad-samples.png" />
<dl class="py function">
<dt class="sig sig-object py" id="lsqfitgp.Celerite">
<span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">Celerite</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">delta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfitgp.Celerite" title="Permalink to this definition">¶</a></dt>
<dd><p>Celerite kernel.</p>
<div class="math notranslate nohighlight">
\[k(\Delta) = \exp(-\gamma|\Delta|)
\big( \cos(\Delta) + B \sin(|\Delta|) \big)\]</div>
<p>This is the covariance function of an AR(2) process with complex roots. The
parameters must satisfy the condition <span class="math notranslate nohighlight">\(|B| \le \gamma\)</span>. For
<span class="math notranslate nohighlight">\(B = \gamma\)</span> it is equivalent to the <a class="reference internal" href="#lsqfitgp.Harmonic" title="lsqfitgp.Harmonic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Harmonic</span></code></a> kernel with
<span class="math notranslate nohighlight">\(\eta Q = 1/B, Q &gt; 1\)</span>, and it is derivable.</p>
<p>Reference: Daniel Foreman-Mackey, Eric Agol, Sivaram Ambikasaran, and Ruth
Angus: <em>Fast and Scalable Gaussian Process Modeling With Applications To
Astronomical Time Series</em>.</p>
</dd></dl>

<img alt="_images/kernelsref-Celerite.png" src="_images/kernelsref-Celerite.png" />
<img alt="_images/kernelsref-Celerite-samples.png" src="_images/kernelsref-Celerite-samples.png" />
<dl class="py function">
<dt class="sig sig-object py" id="lsqfitgp.Constant">
<span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">Constant</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfitgp.Constant" title="Permalink to this definition">¶</a></dt>
<dd><p>Constant kernel.</p>
<div class="math notranslate nohighlight">
\[k(x, y) = 1\]</div>
<p>This means that all points are completely correlated, thus it is equivalent
to fitting with a horizontal line. This can be seen also by observing that
1 = 1 x 1.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lsqfitgp.Cos">
<span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">Cos</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">delta</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfitgp.Cos" title="Permalink to this definition">¶</a></dt>
<dd><p>Cosine kernel.</p>
<div class="math notranslate nohighlight">
\[k(\Delta) = \cos(\Delta)
= \cos x \cos y + \sin x \sin y\]</div>
<p>Samples from this kernel are harmonic functions. It can be multiplied with
another kernel to introduce anticorrelations.</p>
</dd></dl>

<img alt="_images/kernelsref-Cos.png" src="_images/kernelsref-Cos.png" />
<img alt="_images/kernelsref-Cos-samples.png" src="_images/kernelsref-Cos-samples.png" />
<dl class="py function">
<dt class="sig sig-object py" id="lsqfitgp.Decaying">
<span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">Decaying</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfitgp.Decaying" title="Permalink to this definition">¶</a></dt>
<dd><p>Decaying kernel.</p>
<div class="math notranslate nohighlight">
\[k(x, y) =
\frac{1}{1 + x + y},
\quad x, y \ge 0\]</div>
<p>It is infinitely divisible.</p>
<p>Reference: Swersky, Snoek and Adams (2014).</p>
</dd></dl>

<img alt="_images/kernelsref-Decaying.png" src="_images/kernelsref-Decaying.png" />
<img alt="_images/kernelsref-Decaying-samples.png" src="_images/kernelsref-Decaying-samples.png" />
<dl class="py function">
<dt class="sig sig-object py" id="lsqfitgp.ExpQuad">
<span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">ExpQuad</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">r2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfitgp.ExpQuad" title="Permalink to this definition">¶</a></dt>
<dd><p>Exponential quadratic kernel.</p>
<div class="math notranslate nohighlight">
\[k(r) = \exp \left( -\frac 12 r^2 \right)\]</div>
<p>It is smooth and has a strict typical lengthscale, i.e., oscillations are
strongly suppressed under a certain wavelength, and correlations are
strongly suppressed over a certain distance.</p>
<p>Reference: Rasmussen and Williams (2006, p. 83).</p>
</dd></dl>

<img alt="_images/kernelsref-ExpQuad.png" src="_images/kernelsref-ExpQuad.png" />
<img alt="_images/kernelsref-ExpQuad-samples.png" src="_images/kernelsref-ExpQuad-samples.png" />
<dl class="py function">
<dt class="sig sig-object py" id="lsqfitgp.Expon">
<span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">Expon</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">delta</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfitgp.Expon" title="Permalink to this definition">¶</a></dt>
<dd><p>Exponential kernel.</p>
<div class="math notranslate nohighlight">
\[k(\Delta) = \exp(-|\Delta|)\]</div>
<p>In 1D it is equivalent to the Matérn 1/2 kernel, however in more dimensions
it acts separately while the Matérn kernel is isotropic.</p>
<p>Reference: Rasmussen and Williams (2006, p. 85).</p>
</dd></dl>

<img alt="_images/kernelsref-Expon.png" src="_images/kernelsref-Expon.png" />
<img alt="_images/kernelsref-Expon-samples.png" src="_images/kernelsref-Expon-samples.png" />
<dl class="py function">
<dt class="sig sig-object py" id="lsqfitgp.Fourier">
<span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">Fourier</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">delta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfitgp.Fourier" title="Permalink to this definition">¶</a></dt>
<dd><p>Fourier kernel.</p>
<div class="math notranslate nohighlight">
\[\begin{split}k(\Delta) &amp;= \frac1{\zeta(2n)} \sum_{k=1}^\infty
\frac {\cos(2\pi kx)}{k^n} \frac {\cos(2\pi ky)}{k^n}
+ \frac1{\zeta(2n)} \sum_{k=1}^\infty
\frac {\sin(2\pi kx)}{k^n} \frac {\sin(2\pi ky)}{k^n} = \\
&amp;= \frac1{\zeta(2n)} \sum_{k=1}^\infty
\frac {\cos(2\pi k\Delta)} {k^{2n}} = \\
&amp;= (-1)^{n+1}
\frac1{\zeta(2n)} \frac {(2\pi)^{2n}} {2(2n)!}
B_{2n}(\Delta \bmod 1),\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(B_s(x)\)</span> is a Bernoulli polynomial. It is equivalent to fitting
with a Fourier series of period 1 with independent priors on the
coefficients with mean zero and variance
<span class="math notranslate nohighlight">\(1/(\zeta(2n)k^{2n})\)</span>. The process is <span class="math notranslate nohighlight">\(n - 1\)</span> times
derivable.</p>
<p>Note that the <span class="math notranslate nohighlight">\(k = 0\)</span> term is not included in the summation, so the
mean of the process over one period is forced to be zero.</p>
</dd></dl>

<img alt="_images/kernelsref-Fourier.png" src="_images/kernelsref-Fourier.png" />
<img alt="_images/kernelsref-Fourier-samples.png" src="_images/kernelsref-Fourier-samples.png" />
<dl class="py function">
<dt class="sig sig-object py" id="lsqfitgp.FracBrownian">
<span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">FracBrownian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">K</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfitgp.FracBrownian" title="Permalink to this definition">¶</a></dt>
<dd><p>Bifractional Brownian motion kernel.</p>
<div class="math notranslate nohighlight">
\[k(x, y) = \frac 1{2^K} \big(
    (|x|^{2H} + |y|^{2H})^K - |x-y|^{2HK}
\big), \quad H, K \in (0, 1]\]</div>
<p>For <cite>H</cite> = 1/2 (default) it is the Wiener kernel. For <cite>H</cite> in (0, 1/2) the
increments are anticorrelated (strong oscillation), for <cite>H</cite> in (1/2, 1]
the increments are correlated (tends to keep a slope).</p>
<p>Reference: Houdré and Villa (2003).</p>
</dd></dl>

<img alt="_images/kernelsref-FracBrownian.png" src="_images/kernelsref-FracBrownian.png" />
<img alt="_images/kernelsref-FracBrownian-samples.png" src="_images/kernelsref-FracBrownian-samples.png" />
<dl class="py function">
<dt class="sig sig-object py" id="lsqfitgp.GammaExp">
<span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">GammaExp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">r2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfitgp.GammaExp" title="Permalink to this definition">¶</a></dt>
<dd><p>Gamma exponential kernel.</p>
<div class="math notranslate nohighlight">
\[k(r) = \exp(-r^\gamma), \quad
\gamma \in (0, 2]\]</div>
<p>For <span class="math notranslate nohighlight">\(\gamma = 2\)</span> it is the squared exponential kernel, for
<span class="math notranslate nohighlight">\(\gamma = 1\)</span> (default) it is the Matérn 1/2 kernel, for
<span class="math notranslate nohighlight">\(\gamma \to 0\)</span> it tends to white noise plus a constant. The process
is differentiable only for <span class="math notranslate nohighlight">\(\gamma = 2\)</span>, however as <span class="math notranslate nohighlight">\(\gamma\)</span>
gets closer to 2 the variance of the non-derivable component goes to zero.</p>
<p>Reference: Rasmussen and Williams (2006, p. 86).</p>
</dd></dl>

<img alt="_images/kernelsref-GammaExp.png" src="_images/kernelsref-GammaExp.png" />
<img alt="_images/kernelsref-GammaExp-samples.png" src="_images/kernelsref-GammaExp-samples.png" />
<dl class="py function">
<dt class="sig sig-object py" id="lsqfitgp.Gibbs">
<span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">Gibbs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scalefun=&lt;function</span> <span class="pre">&lt;lambda&gt;&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfitgp.Gibbs" title="Permalink to this definition">¶</a></dt>
<dd><p>Gibbs kernel.</p>
<div class="math notranslate nohighlight">
\[k(x, y) = \sqrt{ \frac {2 s(x) s(y)} {s(x)^2 + s(y)^2} }
\exp \left( -\frac {(x - y)^2} {s(x)^2 + s(y)^2} \right),
\quad s = \texttt{scalefun}.\]</div>
<p>Kernel which in some sense is like a Gaussian kernel where the scale
changes at every point. The scale is computed by the parameter <cite>scalefun</cite>
which must be a callable taking the x array and returning a scale for each
point. By default <cite>scalefun</cite> returns 1 so it is a Gaussian kernel.</p>
<p>Consider that the default parameter <cite>scale</cite> acts before <cite>scalefun</cite>, so
for example if <cite>scalefun(x) = x</cite> then <cite>scale</cite> has no effect. You should
include all rescalings in <cite>scalefun</cite> to avoid surprises.</p>
<p>Reference: Rasmussen and Williams (2006, p. 93).</p>
</dd></dl>

<img alt="_images/kernelsref-Gibbs.png" src="_images/kernelsref-Gibbs.png" />
<img alt="_images/kernelsref-Gibbs-samples.png" src="_images/kernelsref-Gibbs-samples.png" />
<dl class="py function">
<dt class="sig sig-object py" id="lsqfitgp.Harmonic">
<span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">Harmonic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">delta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Q</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfitgp.Harmonic" title="Permalink to this definition">¶</a></dt>
<dd><p>Damped stochastically driven harmonic oscillator kernel.</p>
<div class="math notranslate nohighlight">
\[\begin{split}k(\Delta) =
\exp\left( -\frac {|\Delta|} {Q} \right)
\begin{cases}
    \cosh(\eta\Delta) + \sinh(\eta|\Delta|) / (\eta Q)
    &amp; 0 &lt; Q &lt; 1 \\
    1 + |\Delta| &amp; Q = 1 \\
    \cos(\eta\Delta) + \sin(\eta|\Delta|) / (\eta Q)
    &amp; Q &gt; 1,
\end{cases}\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\eta = \sqrt{|1 - 1/Q^2|}\)</span>.</p>
<p>The process is the solution to the stochastic differential equation</p>
<div class="math notranslate nohighlight">
\[f''(x) + 2/Q f'(x) + f(x) = w(x),\]</div>
<p>where <cite>w</cite> is white noise.</p>
<p>The parameter <cite>Q</cite> is the quality factor, i.e., the ratio between the energy
stored in the oscillator and the energy lost in each cycle due to damping.
The angular frequency is 1, i.e., the period is 2π. The process is derivable
one time.</p>
<p>In 1D, for <cite>Q</cite> = 1 (default) and <cite>scale</cite> = sqrt(1/3), it is the Matérn 3/2
kernel.</p>
<p>Reference: Daniel Foreman-Mackey, Eric Agol, Sivaram Ambikasaran, and Ruth
Angus: <em>Fast and Scalable Gaussian Process Modeling With Applications To
Astronomical Time Series</em>.</p>
</dd></dl>

<img alt="_images/kernelsref-Harmonic.png" src="_images/kernelsref-Harmonic.png" />
<img alt="_images/kernelsref-Harmonic-samples.png" src="_images/kernelsref-Harmonic-samples.png" />
<dl class="py function">
<dt class="sig sig-object py" id="lsqfitgp.HoleEffect">
<span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">HoleEffect</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">delta</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfitgp.HoleEffect" title="Permalink to this definition">¶</a></dt>
<dd><p>Hole effect kernel.</p>
<div class="math notranslate nohighlight">
\[k(\Delta) = (1 - \Delta) \exp(-\Delta)\]</div>
<p>Reference: Dietrich and Newsam (1997, p. 1096).</p>
</dd></dl>

<img alt="_images/kernelsref-HoleEffect.png" src="_images/kernelsref-HoleEffect.png" />
<img alt="_images/kernelsref-HoleEffect-samples.png" src="_images/kernelsref-HoleEffect-samples.png" />
<dl class="py function">
<dt class="sig sig-object py" id="lsqfitgp.Linear">
<span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">Linear</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfitgp.Linear" title="Permalink to this definition">¶</a></dt>
<dd><p>Dot product kernel.</p>
<div class="math notranslate nohighlight">
\[k(x, y) = x \cdot y = \sum_i x_i y_i\]</div>
<p>In 1D it is equivalent to fitting with a line passing by the origin.</p>
<p>Reference: Rasmussen and Williams (2006, p. 89).</p>
</dd></dl>

<img alt="_images/kernelsref-Linear.png" src="_images/kernelsref-Linear.png" />
<img alt="_images/kernelsref-Linear-samples.png" src="_images/kernelsref-Linear-samples.png" />
<dl class="py function">
<dt class="sig sig-object py" id="lsqfitgp.Log">
<span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">Log</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">r</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfitgp.Log" title="Permalink to this definition">¶</a></dt>
<dd><p>Log kernel.</p>
<div class="math notranslate nohighlight">
\[k(r) = \log(1 + r) / r\]</div>
<p>From <a class="reference external" href="https://github.com/wesselb/mlkernels">https://github.com/wesselb/mlkernels</a>.</p>
</dd></dl>

<img alt="_images/kernelsref-Log.png" src="_images/kernelsref-Log.png" />
<img alt="_images/kernelsref-Log-samples.png" src="_images/kernelsref-Log-samples.png" />
<dl class="py function">
<dt class="sig sig-object py" id="lsqfitgp.Matern">
<span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">Matern</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">r2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nu</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfitgp.Matern" title="Permalink to this definition">¶</a></dt>
<dd><p>Matérn kernel of real order.</p>
<div class="math notranslate nohighlight">
\[k(r) = \frac {2^{1-\nu}} {\Gamma(\nu)} x^\nu K_\nu(x),
\quad \nu &gt; 0,
\quad x = \sqrt{2\nu} r\]</div>
<p>The nearest integer below <span class="math notranslate nohighlight">\(\nu\)</span> indicates how many times the
Gaussian process is derivable: so for <span class="math notranslate nohighlight">\(\nu &lt; 1\)</span> it is continuous but
not derivable, for <span class="math notranslate nohighlight">\(1 \le \nu &lt; 2\)</span> it is derivable but has not a
second derivative, etc.</p>
<p>Reference: Rasmussen and Williams (2006, p. 84).</p>
</dd></dl>

<img alt="_images/kernelsref-Matern.png" src="_images/kernelsref-Matern.png" />
<img alt="_images/kernelsref-Matern-samples.png" src="_images/kernelsref-Matern-samples.png" />
<dl class="py function">
<dt class="sig sig-object py" id="lsqfitgp.Maternp">
<span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">Maternp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">r</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfitgp.Maternp" title="Permalink to this definition">¶</a></dt>
<dd><p>Matérn kernel of half-integer order.</p>
<div class="math notranslate nohighlight">
\[\begin{split}k(r) &amp;= \frac {2^{1-\nu}} {\Gamma(\nu)} x^\nu K_\nu(x) = \\
&amp;= \exp(-x) \frac{p!}{(2p)!}
\sum_{i=0}^p \frac{(p+i)!}{i!(p-i)!} (2x)^{p-i} \\
\nu &amp;= p + 1/2,
p \in \mathbb N,
x = \sqrt{2\nu} r\end{split}\]</div>
<p>The degree of derivability is <cite>p</cite>.</p>
<p>Reference: Rasmussen and Williams (2006, p. 85).</p>
</dd></dl>

<img alt="_images/kernelsref-Maternp.png" src="_images/kernelsref-Maternp.png" />
<img alt="_images/kernelsref-Maternp-samples.png" src="_images/kernelsref-Maternp-samples.png" />
<dl class="py function">
<dt class="sig sig-object py" id="lsqfitgp.NNKernel">
<span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">NNKernel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfitgp.NNKernel" title="Permalink to this definition">¶</a></dt>
<dd><p>Neural network kernel.</p>
<div class="math notranslate nohighlight">
\[k(x, y) = \frac 2 \pi
\arcsin \left( \frac
{
    2 (q + x \cdot y)
}{
    (1 + 2 (q + x \cdot x))
    (1 + 2 (q + y \cdot y))
}
\right),
\quad q = \texttt{sigma0}^2\]</div>
<p>Kernel which is equivalent to a neural network with one infinite hidden
layer with Gaussian priors on the weights and error function response. In
other words, you can think of the process as a superposition of sigmoids
where <cite>sigma0</cite> sets the dispersion of the centers of the sigmoids.</p>
<p>Reference: Rasmussen and Williams (2006, p. 90).</p>
</dd></dl>

<img alt="_images/kernelsref-NNKernel.png" src="_images/kernelsref-NNKernel.png" />
<img alt="_images/kernelsref-NNKernel-samples.png" src="_images/kernelsref-NNKernel-samples.png" />
<dl class="py function">
<dt class="sig sig-object py" id="lsqfitgp.OrnsteinUhlenbeck">
<span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">OrnsteinUhlenbeck</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfitgp.OrnsteinUhlenbeck" title="Permalink to this definition">¶</a></dt>
<dd><p>Ornstein-Uhlenbeck process kernel.</p>
<div class="math notranslate nohighlight">
\[k(x, y) = \exp(-|x - y|) - \exp(-(x + y)),
\quad x, y \ge 0\]</div>
<p>It is a random walk plus a negative feedback term that keeps the
asymptotical variance constant. It is asymptotically stationary; often the
name “Ornstein-Uhlenbeck” is given to the stationary part only, which here
is provided as <a class="reference internal" href="#lsqfitgp.Expon" title="lsqfitgp.Expon"><code class="xref py py-class docutils literal notranslate"><span class="pre">Expon</span></code></a>.</p>
</dd></dl>

<img alt="_images/kernelsref-OrnsteinUhlenbeck.png" src="_images/kernelsref-OrnsteinUhlenbeck.png" />
<img alt="_images/kernelsref-OrnsteinUhlenbeck-samples.png" src="_images/kernelsref-OrnsteinUhlenbeck-samples.png" />
<dl class="py function">
<dt class="sig sig-object py" id="lsqfitgp.PPKernel">
<span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">PPKernel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">r</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">D</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfitgp.PPKernel" title="Permalink to this definition">¶</a></dt>
<dd><p>Piecewise polynomial kernel.</p>
<div class="math notranslate nohighlight">
\[\begin{split}k(r) = \text{polynomial}_{q,D}(r)
\begin{cases}
    1 - r &amp; r \in [0, 1)     \\
    0     &amp; \text{otherwise}
\end{cases}\end{split}\]</div>
<p>An isotropic kernel with finite support. The covariance is nonzero only
when the distance between the points is less than 1. Parameter <cite>q</cite> in (0,
1, 2, 3) sets the differentiability, while parameter <cite>D</cite> sets the maximum
dimensionality the kernel can be used with. Default is <cite>q</cite> = 0 (non
derivable), <cite>D</cite> = 1 (can be used only in 1D).</p>
<p>Reference: Rasmussen and Williams (2006, p. 87).</p>
</dd></dl>

<img alt="_images/kernelsref-PPKernel.png" src="_images/kernelsref-PPKernel.png" />
<img alt="_images/kernelsref-PPKernel-samples.png" src="_images/kernelsref-PPKernel-samples.png" />
<dl class="py function">
<dt class="sig sig-object py" id="lsqfitgp.Periodic">
<span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">Periodic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">delta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">outerscale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfitgp.Periodic" title="Permalink to this definition">¶</a></dt>
<dd><p>Periodic Gaussian kernel.</p>
<div class="math notranslate nohighlight">
\[k(\Delta) = \exp \left(
-2 \left(
\frac {\sin(\Delta / 2)} {\texttt{outerscale}}
\right)^2
\right)\]</div>
<p>A Gaussian kernel over a transformed periodic space. It represents a
periodic process. The usual <cite>scale</cite> parameter sets the period, with the
default <cite>scale</cite> = 1 giving a period of 2π, while the <cite>outerscale</cite> parameter
sets the length scale of the correlations.</p>
<p>Reference: Rasmussen and Williams (2006, p. 92).</p>
</dd></dl>

<img alt="_images/kernelsref-Periodic.png" src="_images/kernelsref-Periodic.png" />
<img alt="_images/kernelsref-Periodic-samples.png" src="_images/kernelsref-Periodic-samples.png" />
<dl class="py function">
<dt class="sig sig-object py" id="lsqfitgp.Pink">
<span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">Pink</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">delta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dw</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfitgp.Pink" title="Permalink to this definition">¶</a></dt>
<dd><p>Pink noise kernel.</p>
<div class="math notranslate nohighlight">
\[k(\Delta) = \frac 1 {\log(1 + \delta\omega)}
\int_1^{1+\delta\omega} \mathrm d\omega
\frac{\cos(\omega\Delta)}\omega\]</div>
<p>A process with power spectrum <span class="math notranslate nohighlight">\(1/\omega\)</span> truncated between 1 and
<span class="math notranslate nohighlight">\(1 + \delta\omega\)</span>. <span class="math notranslate nohighlight">\(\omega\)</span> is the angular frequency
<span class="math notranslate nohighlight">\(\omega = 2\pi f\)</span>. In the limit <span class="math notranslate nohighlight">\(\delta\omega\to\infty\)</span>
it becomes white noise. Derivable one time.</p>
</dd></dl>

<img alt="_images/kernelsref-Pink.png" src="_images/kernelsref-Pink.png" />
<img alt="_images/kernelsref-Pink-samples.png" src="_images/kernelsref-Pink-samples.png" />
<dl class="py function">
<dt class="sig sig-object py" id="lsqfitgp.Rescaling">
<span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">Rescaling</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stdfun</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfitgp.Rescaling" title="Permalink to this definition">¶</a></dt>
<dd><p>Outer product kernel.</p>
<div class="math notranslate nohighlight">
\[k(x, y) = \texttt{stdfun}(x) \texttt{stdfun}(y)\]</div>
<p>A totally correlated kernel with arbitrary variance. Parameter <cite>stdfun</cite>
must be a function that takes <cite>x</cite> or <cite>y</cite> and computes the standard
deviation at the point. It can yield negative values; points with the same
sign of <cite>fun</cite> will be totally correlated, points with different sign will
be totally anticorrelated. Use this kernel to modulate the variance of
other kernels. By default <cite>stdfun</cite> returns a constant, so it is equivalent
to <a class="reference internal" href="#lsqfitgp.Constant" title="lsqfitgp.Constant"><code class="xref py py-class docutils literal notranslate"><span class="pre">Constant</span></code></a>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lsqfitgp.Sinc">
<span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">Sinc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">delta</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfitgp.Sinc" title="Permalink to this definition">¶</a></dt>
<dd><p>Sinc kernel.</p>
<div class="math notranslate nohighlight">
\[k(\Delta) = \operatorname{sinc}(\Delta) =
\frac{\sin(\pi\Delta)}{\pi\Delta}.\]</div>
<p>Reference: Tobar (2019).</p>
</dd></dl>

<img alt="_images/kernelsref-Sinc.png" src="_images/kernelsref-Sinc.png" />
<img alt="_images/kernelsref-Sinc-samples.png" src="_images/kernelsref-Sinc-samples.png" />
<dl class="py function">
<dt class="sig sig-object py" id="lsqfitgp.StationaryFracBrownian">
<span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">StationaryFracBrownian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">delta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfitgp.StationaryFracBrownian" title="Permalink to this definition">¶</a></dt>
<dd><p>Stationary fractional brownian motion kernel.</p>
<div class="math notranslate nohighlight">
\[k(\Delta) = \frac 12 (|\Delta+1|^{2H} + |\Delta-1|^{2H} - 2|\Delta|^{2H}),
\quad H \in (0, 1]\]</div>
<p>Reference: Gneiting and Schlather (2006, p. 272).</p>
</dd></dl>

<img alt="_images/kernelsref-StationaryFracBrownian.png" src="_images/kernelsref-StationaryFracBrownian.png" />
<img alt="_images/kernelsref-StationaryFracBrownian-samples.png" src="_images/kernelsref-StationaryFracBrownian-samples.png" />
<dl class="py function">
<dt class="sig sig-object py" id="lsqfitgp.Taylor">
<span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">Taylor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfitgp.Taylor" title="Permalink to this definition">¶</a></dt>
<dd><p>Exponential-like power series kernel.</p>
<div class="math notranslate nohighlight">
\[k(x, y) = \sum_{k=0}^\infty \frac {x^k}{k!} \frac {y^k}{k!}
= I_0(2 \sqrt{xy})\]</div>
<p>It is equivalent to fitting with a Taylor series expansion in zero with
independent priors on the coefficients k with mean zero and standard
deviation 1/k!.</p>
</dd></dl>

<img alt="_images/kernelsref-Taylor.png" src="_images/kernelsref-Taylor.png" />
<img alt="_images/kernelsref-Taylor-samples.png" src="_images/kernelsref-Taylor-samples.png" />
<dl class="py function">
<dt class="sig sig-object py" id="lsqfitgp.White">
<span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">White</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfitgp.White" title="Permalink to this definition">¶</a></dt>
<dd><p>White noise kernel.</p>
<div class="math notranslate nohighlight">
\[\begin{split}k(x, y) = \begin{cases}
    1 &amp; x = y     \\
    0 &amp; x \neq y
\end{cases}\end{split}\]</div>
</dd></dl>

<img alt="_images/kernelsref-White.png" src="_images/kernelsref-White.png" />
<img alt="_images/kernelsref-White-samples.png" src="_images/kernelsref-White-samples.png" />
<dl class="py function">
<dt class="sig sig-object py" id="lsqfitgp.Wiener">
<span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">Wiener</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfitgp.Wiener" title="Permalink to this definition">¶</a></dt>
<dd><p>Wiener kernel.</p>
<div class="math notranslate nohighlight">
\[k(x, y) = \min(x, y), \quad x, y &gt; 0\]</div>
<p>A kernel representing a non-differentiable random walk starting at 0.</p>
<p>Reference: Rasmussen and Williams (2006, p. 94).</p>
</dd></dl>

<img alt="_images/kernelsref-Wiener.png" src="_images/kernelsref-Wiener.png" />
<img alt="_images/kernelsref-Wiener-samples.png" src="_images/kernelsref-Wiener-samples.png" />
<dl class="py function">
<dt class="sig sig-object py" id="lsqfitgp.WienerIntegral">
<span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">WienerIntegral</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfitgp.WienerIntegral" title="Permalink to this definition">¶</a></dt>
<dd><p>Kernel for a process whose derivative is a Wiener process.</p>
<div class="math notranslate nohighlight">
\[k(x, y) = \frac 12 a^2 \left(b - \frac a3 \right),
\quad a = \min(x, y), b = \max(x, y)\]</div>
</dd></dl>

<img alt="_images/kernelsref-WienerIntegral.png" src="_images/kernelsref-WienerIntegral.png" />
<img alt="_images/kernelsref-WienerIntegral-samples.png" src="_images/kernelsref-WienerIntegral-samples.png" />
</section>
</section>


          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="reference.html" title="Previous document">Reference manual</a>
        </li>
        <li>
          <a href="kernel.html" title="Next document"><span class="section-number">2. </span>Generic kernel classes</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;2020-2022, Giacomo Petrillo.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 5.0.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/kernelsref.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>