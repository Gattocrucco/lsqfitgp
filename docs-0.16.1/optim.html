<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>14. Optimization &#8212; lsqfitgp 0.16.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/sphinx_highlight.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Reference manual" href="reference.html" />
    <link rel="prev" title="13. Nonlinear models" href="nonlinear.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">lsqfitgp 0.16.1</a></h1>



<p class="blurb">A general purpose Gaussian process regression module</p>




<p>
<iframe src="https://ghbtns.com/github-btn.html?user=Gattocrucco&repo=lsqfitgp&type=star&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>





<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="userguide.html">User guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="installation.html">1. Installation</a></li>
<li class="toctree-l2"><a class="reference internal" href="sine.html">2. First example: a sine</a></li>
<li class="toctree-l2"><a class="reference internal" href="kernels.html">3. More on kernels</a></li>
<li class="toctree-l2"><a class="reference internal" href="derivatives.html">4. Taking derivatives</a></li>
<li class="toctree-l2"><a class="reference internal" href="integrals.html">5. Taking integrals</a></li>
<li class="toctree-l2"><a class="reference internal" href="customs.html">6. A custom kernel: text classification</a></li>
<li class="toctree-l2"><a class="reference internal" href="in.html">7. Multidimensional input</a></li>
<li class="toctree-l2"><a class="reference internal" href="partial.html">8. Partial derivatives</a></li>
<li class="toctree-l2"><a class="reference internal" href="out.html">9. Multidimensional output</a></li>
<li class="toctree-l2"><a class="reference internal" href="components.html">10. Splitting components</a></li>
<li class="toctree-l2"><a class="reference internal" href="hyper.html">11. Hyperparameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="hyperstruct.html">12. Hyperparameters in the input</a></li>
<li class="toctree-l2"><a class="reference internal" href="nonlinear.html">13. Nonlinear models</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">14. Optimization</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="reference.html">Reference manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples.html">Examples</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
  <li><a href="userguide.html">User guide</a><ul>
      <li>Previous: <a href="nonlinear.html" title="previous chapter"><span class="section-number">13. </span>Nonlinear models</a></li>
      <li>Next: <a href="reference.html" title="next chapter">Reference manual</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
              <div class="related top">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="nonlinear.html" title="Previous document"><span class="section-number">13. </span>Nonlinear models</a>
        </li>
        <li>
          <a href="reference.html" title="Next document">Reference manual</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          

          <div class="body" role="main">
            
  <span class="target" id="optim"></span><section id="optimization">
<h1><span class="section-number">14. </span>Optimization<a class="headerlink" href="#optimization" title="Permalink to this heading">¶</a></h1>
<section id="evaluating-a-single-gaussian-process-posterior">
<h2><span class="section-number">14.1. </span>Evaluating a single Gaussian process posterior<a class="headerlink" href="#evaluating-a-single-gaussian-process-posterior" title="Permalink to this heading">¶</a></h2>
<p>There are three main computational steps when doing a Gaussian process fit with
<a class="reference internal" href="gp.html#lsqfitgp.GP" title="lsqfitgp.GP"><code class="xref py py-class docutils literal notranslate"><span class="pre">GP</span></code></a>:</p>
<blockquote>
<div><ul class="simple">
<li><p>Compute the prior covariance matrix using the kernel. This is <span class="math notranslate nohighlight">\(O((n +
m)^2)\)</span> where <code class="xref py py-obj docutils literal notranslate"><span class="pre">n</span></code> is the number of datapoints and <code class="xref py py-obj docutils literal notranslate"><span class="pre">m</span></code> the number of
additional points where the posterior is computed.</p></li>
<li><p>Decompose the prior covariance matrix. This is <span class="math notranslate nohighlight">\(O(n^3)\)</span>.</p></li>
<li><p>Take random samples from the posterior. This is <span class="math notranslate nohighlight">\(O(m^3)\)</span>.</p></li>
</ul>
</div></blockquote>
<p>Since usually <span class="math notranslate nohighlight">\(m \gg n\)</span> because the plot is done on a finely spaced grid,
the typical bottleneck is taking the samples, i.e., calling <a class="reference external" href="https://gvar.readthedocs.io/en/latest/gvar.html#gvar.sample" title="(in gvar v11.11.2)"><code class="xref py py-func docutils literal notranslate"><span class="pre">gvar.sample()</span></code></a>
(or <a class="reference external" href="https://gvar.readthedocs.io/en/latest/gvar.html#gvar.raniter" title="(in gvar v11.11.2)"><code class="xref py py-func docutils literal notranslate"><span class="pre">gvar.raniter()</span></code></a>). This problem can be bypassed by plotting only the
standard deviation band instead of taking samples, but it is less informative.
To make <a class="reference external" href="https://gvar.readthedocs.io/en/latest/gvar.html#gvar.sample" title="(in gvar v11.11.2)"><code class="xref py py-func docutils literal notranslate"><span class="pre">gvar.sample()</span></code></a> faster, use its <code class="docutils literal notranslate"><span class="pre">eps</span></code> option: <code class="docutils literal notranslate"><span class="pre">gvar.sample(x,</span>
<span class="pre">eps=1e-12)</span></code>. This forces it to use a Cholesky decomposition instead of a
diagonalization.</p>
<p>In general the <a class="reference internal" href="gp.html#lsqfitgp.GP" title="lsqfitgp.GP"><code class="xref py py-class docutils literal notranslate"><span class="pre">GP</span></code></a> methods have options for doing everything without
<a class="reference external" href="https://gvar.readthedocs.io/en/latest/gvar.html#module-gvar" title="(in gvar v11.11.2)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">gvar</span></code></a>, but don’t try to use all of them mindlessly before profiling the
code to know where the bottleneck actually is. Python has the module
<code class="xref py py-mod docutils literal notranslate"><span class="pre">cProfile</span></code> for that, and in an IPython shell you can use <code class="docutils literal notranslate"><span class="pre">%run</span> <span class="pre">-p</span></code>. If
you opt out of gvars, you can use <a class="reference internal" href="raniter.html#lsqfitgp.raniter" title="lsqfitgp.raniter"><code class="xref py py-func docutils literal notranslate"><span class="pre">lsqfitgp.raniter()</span></code></a> to draw samples from
an explicit mean vector and covariance matrix instead of <a class="reference external" href="https://gvar.readthedocs.io/en/latest/gvar.html#gvar.raniter" title="(in gvar v11.11.2)"><code class="xref py py-func docutils literal notranslate"><span class="pre">gvar.raniter()</span></code></a>.</p>
<p>Once you have solved eventual <a class="reference external" href="https://gvar.readthedocs.io/en/latest/gvar.html#module-gvar" title="(in gvar v11.11.2)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">gvar</span></code></a>-related issues, if you have at least
some hundreds of datapoints the next bottleneck is probably in
<a class="reference internal" href="gp.html#lsqfitgp.GP.predfromdata" title="lsqfitgp.GP.predfromdata"><code class="xref py py-meth docutils literal notranslate"><span class="pre">GP.predfromdata()</span></code></a>. Making it faster is quick: select a solver different
from the default one when initializing the <a class="reference internal" href="gp.html#lsqfitgp.GP" title="lsqfitgp.GP"><code class="xref py py-class docutils literal notranslate"><span class="pre">GP</span></code></a> object, like <code class="docutils literal notranslate"><span class="pre">GP(kernel,</span>
<span class="pre">solver='chol')</span></code>. And don’t forget to disable the <span class="math notranslate nohighlight">\(O((n+m)^2)\)</span> positivity
check: <code class="docutils literal notranslate"><span class="pre">GP(kernel,</span> <span class="pre">solver='chol',</span> <span class="pre">checkpos=False)</span></code>.</p>
<p>If you have written a custom kernel, it may become a bottleneck. For example the
letter counting kernel in <a class="reference internal" href="customs.html#customs"><span class="std std-ref">A custom kernel: text classification</span></a> was very slow. A quick way to get a 2x
improvement is computing only half of the covariance matrix: <code class="docutils literal notranslate"><span class="pre">GP(kernel,</span>
<span class="pre">checksym=False,</span> <span class="pre">halfmatrix=True)</span></code>. Note however that in some cases this may
cause a large perfomance hit, so by default the full covariance matrix is
computed even if <code class="docutils literal notranslate"><span class="pre">checksym=False</span></code> (but the cross covariance matrices are not
computed twice).</p>
</section>
<section id="the-jax-compiler">
<h2><span class="section-number">14.2. </span>The JAX compiler<a class="headerlink" href="#the-jax-compiler" title="Permalink to this heading">¶</a></h2>
<p>Since <a class="reference internal" href="index.html#module-lsqfitgp" title="lsqfitgp"><code class="xref py py-mod docutils literal notranslate"><span class="pre">lsqfitgp</span></code></a> uses JAX as computational backend, which provides a just
in time compiler (JIT), in many cases a piece of code doing stuff with a
Gaussian process can be put into a function and compiled to low-level
instructions with <code class="docutils literal notranslate"><span class="pre">jax.jit</span></code>, provided all the array operations are
implemented with <code class="docutils literal notranslate"><span class="pre">jax.numpy</span></code> instead of <code class="docutils literal notranslate"><span class="pre">numpy</span></code>, and gvars are avoided.
Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">jax</span>
<span class="kn">from</span> <span class="nn">jax</span> <span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">jnp</span>
<span class="kn">import</span> <span class="nn">lsqfitgp</span> <span class="k">as</span> <span class="nn">lgp</span>

<span class="k">def</span> <span class="nf">doinference</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
    <span class="n">xplot</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
    <span class="n">gp</span> <span class="o">=</span> <span class="n">lgp</span><span class="o">.</span><span class="n">GP</span><span class="p">(</span><span class="n">lgp</span><span class="o">.</span><span class="n">ExpQuad</span><span class="p">(),</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>
    <span class="n">gp</span><span class="o">.</span><span class="n">addx</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s1">&#39;data&#39;</span><span class="p">)</span>
    <span class="n">gp</span><span class="o">.</span><span class="n">addx</span><span class="p">(</span><span class="n">xplot</span><span class="p">,</span> <span class="s1">&#39;plot&#39;</span><span class="p">)</span>
    <span class="n">yplot_mean</span><span class="p">,</span> <span class="n">yplot_cov</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">predfromdata</span><span class="p">({</span><span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="n">data</span><span class="p">},</span> <span class="s1">&#39;plot&#39;</span><span class="p">,</span> <span class="n">raw</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="c1"># notice we use raw=True to return mean and covariance separately</span>
    <span class="c1"># instead of implicitly tracked into gvars</span>
    <span class="n">yplot_sdev</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">yplot_cov</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">yplot_mean</span><span class="p">,</span> <span class="n">yplot_sdev</span>

<span class="n">doinference_compiled</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">doinference</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;solver&#39;</span><span class="p">,</span> <span class="s1">&#39;checkpos&#39;</span><span class="p">,</span> <span class="s1">&#39;checksym&#39;</span><span class="p">])</span>
<span class="c1"># static_argnames indicates the function parameters that are not numerical</span>
<span class="c1"># and should not be dealt with by the compiler, I&#39;ve put some I will use</span>
<span class="c1"># later</span>

<span class="kn">import</span> <span class="nn">timeit</span>

<span class="k">def</span> <span class="nf">benchmark</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">timer</span> <span class="o">=</span> <span class="n">timeit</span><span class="o">.</span><span class="n">Timer</span><span class="p">(</span><span class="s1">&#39;func(*args, **kwargs)&#39;</span><span class="p">,</span> <span class="nb">globals</span><span class="o">=</span><span class="nb">locals</span><span class="p">())</span>
    <span class="n">n</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">timer</span><span class="o">.</span><span class="n">autorange</span><span class="p">()</span>
    <span class="n">times</span> <span class="o">=</span> <span class="n">timer</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">time</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">times</span><span class="p">)</span> <span class="o">/</span> <span class="n">n</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1"> took </span><span class="si">{</span><span class="n">time</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">1e3</span><span class="si">:</span><span class="s1">7.3f</span><span class="si">}</span><span class="s1"> ms on average&#39;</span><span class="p">)</span>

<span class="n">data</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="n">benchmark</span><span class="p">(</span><span class="n">doinference</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
<span class="n">benchmark</span><span class="p">(</span><span class="n">doinference_compiled</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
<p>And the winner is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">doinference</span> <span class="n">took</span>   <span class="mf">5.651</span> <span class="n">ms</span> <span class="n">on</span> <span class="n">average</span>
<span class="n">doinference</span> <span class="n">took</span>   <span class="mf">0.074</span> <span class="n">ms</span> <span class="n">on</span> <span class="n">average</span>
</pre></div>
</div>
<p>The compiled version is 70 times faster. The difference is so stark because we
used only 10 datapoints, so most of the time is spent in routing overhead
instead of actual computations. Repeating with 1000 datapoints, the advantage
should be limited:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">data</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span>
<span class="n">benchmark</span><span class="p">(</span><span class="n">doinference</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
<span class="n">benchmark</span><span class="p">(</span><span class="n">doinference_compiled</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
<p>Indeed:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">doinference</span> <span class="n">took</span> <span class="mf">356.814</span> <span class="n">ms</span> <span class="n">on</span> <span class="n">average</span>
<span class="n">doinference</span> <span class="n">took</span> <span class="mf">187.924</span> <span class="n">ms</span> <span class="n">on</span> <span class="n">average</span>
</pre></div>
</div>
<p>With many datapoints we said that changing the <a class="reference internal" href="gp.html#lsqfitgp.GP" title="lsqfitgp.GP"><code class="xref py py-class docutils literal notranslate"><span class="pre">GP</span></code></a> options is the
important tweak. Let’s check:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">kw</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">solver</span><span class="o">=</span><span class="s1">&#39;chol&#39;</span><span class="p">,</span> <span class="n">checkpos</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">checksym</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">benchmark</span><span class="p">(</span><span class="n">doinference</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
<span class="n">benchmark</span><span class="p">(</span><span class="n">doinference_compiled</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
</pre></div>
</div>
<p>Result:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">doinference</span> <span class="n">took</span>  <span class="mf">54.725</span> <span class="n">ms</span> <span class="n">on</span> <span class="n">average</span>
<span class="n">doinference</span> <span class="n">took</span>  <span class="mf">16.106</span> <span class="n">ms</span> <span class="n">on</span> <span class="n">average</span>
</pre></div>
</div>
<p>As expected.</p>
</section>
<section id="fitting-hyperparameters">
<h2><span class="section-number">14.3. </span>Fitting hyperparameters<a class="headerlink" href="#fitting-hyperparameters" title="Permalink to this heading">¶</a></h2>
<p>The function <a class="reference internal" href="fit.html#lsqfitgp.empbayes_fit" title="lsqfitgp.empbayes_fit"><code class="xref py py-class docutils literal notranslate"><span class="pre">empbayes_fit</span></code></a> finds the “optimal” hyperparameters by
feeding the GP-factory you give to it into a minimization routine that tries to
change the hyperparameters one step at a time and each time recreates the GP
object and does some computations to check how a “good fit” it is for the given
data.</p>
<p>From the point of view of computational efficiency this means that, apart from
taking posterior samples, the other techniques explained in the previous
sections also apply here. In particular, when the number of datapoints <code class="xref py py-obj docutils literal notranslate"><span class="pre">n</span></code>
starts to be in the hundreds, to speed up the fit do:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">GP</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="s1">&#39;chol&#39;</span><span class="p">,</span> <span class="n">checkpos</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>when you create the <a class="reference internal" href="gp.html#lsqfitgp.GP" title="lsqfitgp.GP"><code class="xref py py-class docutils literal notranslate"><span class="pre">GP</span></code></a> object in the factory function.
<a class="reference internal" href="fit.html#lsqfitgp.empbayes_fit" title="lsqfitgp.empbayes_fit"><code class="xref py py-class docutils literal notranslate"><span class="pre">empbayes_fit</span></code></a> applies the jit for you if passed the <code class="docutils literal notranslate"><span class="pre">jit=True</span></code>
option, so you don’t have to deal with it yourself.</p>
</section>
</section>


          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="nonlinear.html" title="Previous document"><span class="section-number">13. </span>Nonlinear models</a>
        </li>
        <li>
          <a href="reference.html" title="Next document">Reference manual</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;2020-2023, Giacomo Petrillo.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.0.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="_sources/optim.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>