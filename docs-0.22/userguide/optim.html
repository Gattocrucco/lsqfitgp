<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>14. Optimization &#8212; lsqfitgp documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=5ecbeea2" />
    <link rel="stylesheet" type="text/css" href="../_static/basic.css?v=b08954a9" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=f6a572b4" />
    <script src="../_static/documentation_options.js?v=feaa0556"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Reference" href="../reference/reference.html" />
    <link rel="prev" title="13. Nonlinear models" href="nonlinear.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">lsqfitgp</a></h1>



<p class="blurb">A general purpose Gaussian process regression module</p>




<p>
<iframe src="https://ghbtns.com/github-btn.html?user=Gattocrucco&repo=lsqfitgp&type=star&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>






<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="userguide.html">Guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="installation.html">1. Installation</a></li>
<li class="toctree-l2"><a class="reference internal" href="sine.html">2. First example: a sine</a></li>
<li class="toctree-l2"><a class="reference internal" href="kernels.html">3. More on kernels</a></li>
<li class="toctree-l2"><a class="reference internal" href="derivatives.html">4. Taking derivatives</a></li>
<li class="toctree-l2"><a class="reference internal" href="integrals.html">5. Taking integrals</a></li>
<li class="toctree-l2"><a class="reference internal" href="customs.html">6. A custom kernel: text classification</a></li>
<li class="toctree-l2"><a class="reference internal" href="in.html">7. Multidimensional input</a></li>
<li class="toctree-l2"><a class="reference internal" href="partial.html">8. Partial derivatives</a></li>
<li class="toctree-l2"><a class="reference internal" href="out.html">9. Multidimensional output</a></li>
<li class="toctree-l2"><a class="reference internal" href="components.html">10. Splitting components</a></li>
<li class="toctree-l2"><a class="reference internal" href="hyper.html">11. Hyperparameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="hyperstruct.html">12. Hyperparameters in the input</a></li>
<li class="toctree-l2"><a class="reference internal" href="nonlinear.html">13. Nonlinear models</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">14. Optimization</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../reference/reference.html">Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../examplesref.html">Example scripts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../development/development.html">Development</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="userguide.html">Guide</a><ul>
      <li>Previous: <a href="nonlinear.html" title="previous chapter"><span class="section-number">13. </span>Nonlinear models</a></li>
      <li>Next: <a href="../reference/reference.html" title="next chapter">Reference</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
              <div class="related top">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="nonlinear.html" title="Previous document"><span class="section-number">13. </span>Nonlinear models</a>
        </li>
        <li>
          <a href="../reference/reference.html" title="Next document">Reference</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          

          <div class="body" role="main">
            
  <section id="optimization">
<span id="optim"></span><h1><span class="section-number">14. </span>Optimization<a class="headerlink" href="#optimization" title="Link to this heading">¶</a></h1>
<section id="evaluating-a-single-gaussian-process-posterior">
<h2><span class="section-number">14.1. </span>Evaluating a single Gaussian process posterior<a class="headerlink" href="#evaluating-a-single-gaussian-process-posterior" title="Link to this heading">¶</a></h2>
<p>There are three main computational steps when doing a Gaussian process fit with
<a class="reference internal" href="../reference/gp.html#lsqfitgp.GP" title="lsqfitgp.GP"><code class="xref py py-class docutils literal notranslate"><span class="pre">GP</span></code></a>:</p>
<blockquote>
<div><ul class="simple">
<li><p>Compute the prior covariance matrix using the kernel. This is <span class="math notranslate nohighlight">\(O((n +
m)^2)\)</span> where <span class="math notranslate nohighlight">\(n\)</span> is the number of datapoints and <span class="math notranslate nohighlight">\(m\)</span> the number
of additional points where the posterior is computed.</p></li>
<li><p>Decompose the prior covariance matrix. This is <span class="math notranslate nohighlight">\(O(n^3)\)</span>.</p></li>
<li><p>Take random samples from the posterior. This is <span class="math notranslate nohighlight">\(O(m^3)\)</span>.</p></li>
</ul>
</div></blockquote>
<p>Additionally, by default <a class="reference internal" href="../reference/gp.html#lsqfitgp.GP" title="lsqfitgp.GP"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GP</span></code></a> checks that the prior covariance matrix is
symmetric and positive semidefinite. This has complexity <span class="math notranslate nohighlight">\(O((n + m)^2)\)</span>,
and the positivity check is somewhat slow. To disable the check, write <code class="docutils literal notranslate"><span class="pre">GP(...,</span>
<span class="pre">checkpos=False,</span> <span class="pre">checksym=False)</span></code>. The check is disabled anyway when using the
jax compiler, addressed in the next section.</p>
<p>Since usually <span class="math notranslate nohighlight">\(m \gg n\)</span> because the plot is done on a finely spaced grid,
the typical bottleneck is taking the samples, i.e., calling <a class="reference external" href="https://gvar.readthedocs.io/en/latest/gvar.html#gvar.sample" title="(in gvar v13.1.7)"><code class="xref py py-func docutils literal notranslate"><span class="pre">gvar.sample()</span></code></a>
(or <a class="reference external" href="https://gvar.readthedocs.io/en/latest/gvar.html#gvar.raniter" title="(in gvar v13.1.7)"><code class="xref py py-func docutils literal notranslate"><span class="pre">gvar.raniter()</span></code></a>). This problem can be bypassed by plotting only the
standard deviation band instead of taking samples, but it is less informative.
To make <a class="reference external" href="https://gvar.readthedocs.io/en/latest/gvar.html#gvar.sample" title="(in gvar v13.1.7)"><code class="xref py py-func docutils literal notranslate"><span class="pre">gvar.sample()</span></code></a> faster, use its <code class="docutils literal notranslate"><span class="pre">eps</span></code> option: <code class="docutils literal notranslate"><span class="pre">gvar.sample(x,</span>
<span class="pre">eps=1e-12)</span></code>. This forces it to use a Cholesky decomposition instead of a
diagonalization.</p>
<p>In general the <a class="reference internal" href="../reference/gp.html#lsqfitgp.GP" title="lsqfitgp.GP"><code class="xref py py-class docutils literal notranslate"><span class="pre">GP</span></code></a> methods have options for doing everything without
<a class="reference external" href="https://gvar.readthedocs.io/en/latest/gvar.html#module-gvar" title="(in gvar v13.1.7)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">gvar</span></code></a>, but don’t try to use all of them mindlessly before profiling the
code to know where the bottleneck actually is. Python has the module
<code class="xref py py-mod docutils literal notranslate"><span class="pre">cProfile</span></code> for that, and in an IPython shell you can use <code class="docutils literal notranslate"><span class="pre">%run</span> <span class="pre">-p</span></code>. If
you opt out of gvars, you can use <a class="reference internal" href="../reference/raniter.html#lsqfitgp.raniter" title="lsqfitgp.raniter"><code class="xref py py-func docutils literal notranslate"><span class="pre">lsqfitgp.raniter()</span></code></a> to draw samples from
an explicit mean vector and covariance matrix instead of <a class="reference external" href="https://gvar.readthedocs.io/en/latest/gvar.html#gvar.raniter" title="(in gvar v13.1.7)"><code class="xref py py-func docutils literal notranslate"><span class="pre">gvar.raniter()</span></code></a>.</p>
<p>If you have written a custom kernel, it may become a bottleneck. For example the
letter counting kernel in <a class="reference internal" href="customs.html#customs"><span class="std std-ref">A custom kernel: text classification</span></a> was very slow. A quick way to get a 2x
improvement is computing only half of the covariance matrix: <code class="docutils literal notranslate"><span class="pre">GP(kernel,</span>
<span class="pre">checksym=False,</span> <span class="pre">halfmatrix=True)</span></code>. Note however that in some cases this may
cause a large perfomance hit (for example in the <a class="reference internal" href="../reference/kernelsref.html#lsqfitgp.BART" title="lsqfitgp.BART"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BART</span></code></a> kernel), so by default
the full covariance matrix is computed even if <code class="docutils literal notranslate"><span class="pre">checksym=False</span></code> (but the cross
covariance matrices are not computed twice).</p>
</section>
<section id="the-jax-compiler">
<h2><span class="section-number">14.2. </span>The JAX compiler<a class="headerlink" href="#the-jax-compiler" title="Link to this heading">¶</a></h2>
<p>Since <a class="reference internal" href="../index.html#module-lsqfitgp" title="lsqfitgp"><code class="xref py py-mod docutils literal notranslate"><span class="pre">lsqfitgp</span></code></a> uses JAX as computational backend, which provides a just
in time compiler (JIT), in many cases a piece of code doing stuff with a
Gaussian process can be put into a function and compiled to low-level
instructions with <code class="docutils literal notranslate"><span class="pre">jax.jit</span></code>, provided all the array operations are
implemented with <code class="docutils literal notranslate"><span class="pre">jax.numpy</span></code> instead of <code class="docutils literal notranslate"><span class="pre">numpy</span></code>, and gvars are avoided.
Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">jax</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">jax</span><span class="w"> </span><span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">jnp</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">lsqfitgp</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">lgp</span>

<span class="k">def</span><span class="w"> </span><span class="nf">doinference</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
    <span class="n">xplot</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
    <span class="n">yplot_mean</span><span class="p">,</span> <span class="n">yplot_cov</span> <span class="o">=</span> <span class="p">(</span><span class="n">lgp</span>
        <span class="o">.</span><span class="n">GP</span><span class="p">(</span><span class="n">lgp</span><span class="o">.</span><span class="n">ExpQuad</span><span class="p">(),</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>
        <span class="o">.</span><span class="n">addx</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s1">&#39;data&#39;</span><span class="p">)</span>
        <span class="o">.</span><span class="n">addx</span><span class="p">(</span><span class="n">xplot</span><span class="p">,</span> <span class="s1">&#39;plot&#39;</span><span class="p">)</span>
        <span class="o">.</span><span class="n">predfromdata</span><span class="p">({</span><span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="n">data</span><span class="p">},</span> <span class="s1">&#39;plot&#39;</span><span class="p">,</span> <span class="n">raw</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="c1"># we use raw=True to return mean and covariance separately</span>
    <span class="c1"># instead of implicitly tracked into gvars</span>
    <span class="n">yplot_sdev</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">yplot_cov</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">yplot_mean</span><span class="p">,</span> <span class="n">yplot_sdev</span>

<span class="n">doinference_compiled</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">doinference</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;checkpos&#39;</span><span class="p">,</span> <span class="s1">&#39;checksym&#39;</span><span class="p">])</span>
<span class="c1"># static_argnames indicates the function parameters that are not numerical</span>
<span class="c1"># and should not be dealt with by the compiler, I&#39;ve put some I will use</span>
<span class="c1"># later</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">timeit</span>

<span class="k">def</span><span class="w"> </span><span class="nf">benchmark</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">jax</span><span class="w"> </span><span class="kn">import</span> <span class="n">block_until_ready</span>
    <span class="n">timer</span> <span class="o">=</span> <span class="n">timeit</span><span class="o">.</span><span class="n">Timer</span><span class="p">(</span><span class="s1">&#39;block_until_ready(func(*args, **kwargs))&#39;</span><span class="p">,</span> <span class="nb">globals</span><span class="o">=</span><span class="nb">locals</span><span class="p">())</span>
    <span class="n">n</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">timer</span><span class="o">.</span><span class="n">autorange</span><span class="p">()</span>
    <span class="n">times</span> <span class="o">=</span> <span class="n">timer</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">time</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">times</span><span class="p">)</span> <span class="o">/</span> <span class="n">n</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1"> took </span><span class="si">{</span><span class="n">time</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">1e3</span><span class="si">:</span><span class="s1">7.3f</span><span class="si">}</span><span class="s1"> ms on average&#39;</span><span class="p">)</span>

<span class="n">data</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="n">benchmark</span><span class="p">(</span><span class="n">doinference</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
<span class="n">benchmark</span><span class="p">(</span><span class="n">doinference_compiled</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
<p>And the winner is:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>doinference took   7.102 ms on average
doinference took   0.041 ms on average
</pre></div>
</div>
<p>The compiled version is 200 times faster. The difference is so stark because we
used only 10 datapoints, so most of the time is spent in routing overhead
instead of actual computations. Repeating with 1000 datapoints, the advantage
should be milder:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">data</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span>
<span class="n">benchmark</span><span class="p">(</span><span class="n">doinference</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
<span class="n">benchmark</span><span class="p">(</span><span class="n">doinference_compiled</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
<p>Indeed, it’s 6x faster, lower but still high:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>doinference took  33.204 ms on average
doinference took   4.804 ms on average
</pre></div>
</div>
<p>We said that using the <a class="reference internal" href="../reference/gp.html#lsqfitgp.GP" title="lsqfitgp.GP"><code class="xref py py-class docutils literal notranslate"><span class="pre">GP</span></code></a> options <code class="docutils literal notranslate"><span class="pre">checkpos=False,</span> <span class="pre">checksym=False</span></code>
makes it faster, and that they are disabled anyway under jit. Let’s check:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">benchmark</span><span class="p">(</span><span class="n">doinference</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">checkpos</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">checksym</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">benchmark</span><span class="p">(</span><span class="n">doinference_compiled</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">checkpos</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">checksym</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>Result:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>doinference took  16.029 ms on average
doinference took   5.010 ms on average
</pre></div>
</div>
<p>As expected, the compiled version is not affected, while the original one gains
a lot of speed: now the advantage is just 3x.</p>
</section>
<section id="fitting-hyperparameters">
<h2><span class="section-number">14.3. </span>Fitting hyperparameters<a class="headerlink" href="#fitting-hyperparameters" title="Link to this heading">¶</a></h2>
<p>The function <a class="reference internal" href="../reference/fit.html#lsqfitgp.empbayes_fit" title="lsqfitgp.empbayes_fit"><code class="xref py py-class docutils literal notranslate"><span class="pre">empbayes_fit</span></code></a> finds the “optimal” hyperparameters by
feeding the GP-factory you give to it into a minimization routine that tries to
change the hyperparameters one step at a time and each time recreates the GP
object and does some computations to check how a “good fit” it is for the given
data.</p>
<p>From the point of view of computational efficiency this means that, apart from
taking posterior samples, the techniques explained in the previous sections also
apply here. However, <a class="reference internal" href="../reference/fit.html#lsqfitgp.empbayes_fit" title="lsqfitgp.empbayes_fit"><code class="xref py py-class docutils literal notranslate"><span class="pre">empbayes_fit</span></code></a> applies the jit for you by default,
so you don’t have to deal with this yourself. If you disable the jit for some
reason, use the options:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">GP</span><span class="p">(</span><span class="o">...</span><span class="p">,</span> <span class="n">checksym</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">checkpos</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>Another way to improve the performance is by tweaking the minimization method.
The main setting is the <code class="docutils literal notranslate"><span class="pre">method</span></code> argument, which picks a sensible preset for
the underlying routine <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html#scipy.optimize.minimize" title="(in SciPy v1.16.0)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.optimize.minimize</span></code></a>. Then, additional
configurations can be specified through the <code class="docutils literal notranslate"><span class="pre">minkw</span></code> argument; to use it, it
may be useful to look at the full argument list passed to <code class="xref py py-obj docutils literal notranslate"><span class="pre">minimize</span></code>, which is
provided after the fit in the attribute <code class="docutils literal notranslate"><span class="pre">minargs</span></code>.</p>
</section>
<section id="floating-point-32-vs-64-bit">
<h2><span class="section-number">14.4. </span>Floating point 32 vs. 64 bit<a class="headerlink" href="#floating-point-32-vs-64-bit" title="Link to this heading">¶</a></h2>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">jax</span></code> by default uses the <code class="xref py py-obj docutils literal notranslate"><span class="pre">float32</span></code> data type for all floating point arrays and
calculations. Upon initialization, <a class="reference internal" href="../index.html#module-lsqfitgp" title="lsqfitgp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">lsqfitgp</span></code></a> configures <code class="xref py py-obj docutils literal notranslate"><span class="pre">jax</span></code> to use <code class="xref py py-obj docutils literal notranslate"><span class="pre">float64</span></code>
instead, like <a class="reference external" href="https://numpy.org/doc/stable/reference/index.html#module-numpy" title="(in NumPy v2.3)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span></code></a>. Although operations with 32 bit floats are about twice as
fast, Gaussian process regression is particularly sensitive to numerical
accuracy. You can reset <code class="xref py py-obj docutils literal notranslate"><span class="pre">jax</span></code>’s default with:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">jax</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="s1">&#39;jax_enable_x64&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>to get a speedup, but this will likely give problems when the number of
datapoints is over 1000, and will break <a class="reference internal" href="../reference/fit.html#lsqfitgp.empbayes_fit" title="lsqfitgp.empbayes_fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">empbayes_fit</span></code></a> unless you make an effort
to tune the minimizer parameters to make it work at <code class="xref py py-obj docutils literal notranslate"><span class="pre">float32</span></code> precision.</p>
</section>
</section>


          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="nonlinear.html" title="Previous document"><span class="section-number">13. </span>Nonlinear models</a>
        </li>
        <li>
          <a href="../reference/reference.html" title="Next document">Reference</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &#169;2020-2025, Giacomo Petrillo.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.2.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="../_sources/userguide/optim.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>