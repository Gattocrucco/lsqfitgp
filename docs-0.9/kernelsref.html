
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>1. Kernels reference &#8212; lsqfitgp 0.9 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="2. Generic kernel classes" href="kernel.html" />
    <link rel="prev" title="Reference manual" href="reference.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">lsqfitgp 0.9</a></h1>



<p class="blurb">A general purpose Gaussian process regression module</p>




<p>
<iframe src="https://ghbtns.com/github-btn.html?user=Gattocrucco&repo=lsqfitgp&type=star&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>





<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="userguide.html">User guide</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="reference.html">Reference manual</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">1. Kernels reference</a></li>
<li class="toctree-l2"><a class="reference internal" href="kernel.html">2. Generic kernel classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="kerneldec.html">3. Kernel decorators</a></li>
<li class="toctree-l2"><a class="reference internal" href="kernelop.html">4. Kernel operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="deriv.html">5. Derivative specification</a></li>
<li class="toctree-l2"><a class="reference internal" href="gp.html">6. Gaussian process class</a></li>
<li class="toctree-l2"><a class="reference internal" href="array.html">7. Structured arrays wrapping</a></li>
<li class="toctree-l2"><a class="reference internal" href="fit.html">8. Fitting</a></li>
<li class="toctree-l2"><a class="reference internal" href="raniter.html">9. Random sampling</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="examples.html">Examples</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
  <li><a href="reference.html">Reference manual</a><ul>
      <li>Previous: <a href="reference.html" title="previous chapter">Reference manual</a></li>
      <li>Next: <a href="kernel.html" title="next chapter"><span class="section-number">2. </span>Generic kernel classes</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
              <div class="related top">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="reference.html" title="Previous document">Reference manual</a>
        </li>
        <li>
          <a href="kernel.html" title="Next document"><span class="section-number">2. </span>Generic kernel classes</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          

          <div class="body" role="main">
            
  <section id="kernels-reference">
<span id="kernels"></span><h1><span class="section-number">1. </span>Kernels reference<a class="headerlink" href="#kernels-reference" title="Permalink to this headline">¶</a></h1>
<p>This is a list of all the specific kernels implemented in <a class="reference internal" href="index.html#module-lsqfitgp" title="lsqfitgp"><code class="xref py py-mod docutils literal notranslate"><span class="pre">lsqfitgp</span></code></a>.</p>
<p>Kernels are reported with a simplified signature where the positional arguments
are <cite>r</cite> or <cite>r2</cite> if the kernel is isotropic, <cite>delta</cite> if it is stationary, or
<cite>x</cite>, <cite>y</cite> for generic kernels, and with only the keyword arguments specific to
the kernel. All kernels also understand the general keyword arguments of
<a class="reference internal" href="kernel.html#lsqfitgp.Kernel" title="lsqfitgp.Kernel"><code class="xref py py-class docutils literal notranslate"><span class="pre">Kernel</span></code></a> or <a class="reference internal" href="kernel.html#lsqfitgp.IsotropicKernel" title="lsqfitgp.IsotropicKernel"><code class="xref py py-class docutils literal notranslate"><span class="pre">IsotropicKernel</span></code></a>, while there are no positional
arguments when instantiating the kernel and the call signature of instances is
always <cite>x</cite>, <cite>y</cite>.</p>
<p>Example: the kernel <a class="reference internal" href="#lsqfitgp.GammaExp" title="lsqfitgp.GammaExp"><code class="xref py py-class docutils literal notranslate"><span class="pre">GammaExp</span></code></a> is listed as <code class="docutils literal notranslate"><span class="pre">GammaExp(r,</span> <span class="pre">gamma=1)</span></code>.
This means you could use it this way:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">lsqfitgp</span> <span class="k">as</span> <span class="nn">lgp</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="n">kernel</span> <span class="o">=</span> <span class="n">lgp</span><span class="o">.</span><span class="n">GammaExp</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="mf">1.4</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
<span class="n">covmat</span> <span class="o">=</span> <span class="n">kernel</span><span class="p">(</span><span class="n">x</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:])</span>
</pre></div>
</div>
<p>On multidimensional input, isotropic kernels will compute the euclidean
distance. In general non-isotropic kernels will act separately on each
dimension, i.e., <span class="math notranslate nohighlight">\(k(x_1,y_1,x_2,y_2) = k(x_1,y_1) k(x_2,y_2)\)</span>, apart from
kernels defined in terms of the dot product.</p>
<p>For all isotropic and stationary (i.e., depending only on <span class="math notranslate nohighlight">\(x - y\)</span>)
kernels <span class="math notranslate nohighlight">\(k(x, x) = 1\)</span>, and the typical lengthscale is approximately 1 for
default values of the keyword parameters, apart from some specific cases like
<a class="reference internal" href="#lsqfitgp.Constant" title="lsqfitgp.Constant"><code class="xref py py-class docutils literal notranslate"><span class="pre">Constant</span></code></a>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Taking second or higher order derivatives might give problems with isotropic
kernels with signature parameter <cite>r</cite>, while those with <cite>r2</cite> won’t have any
issue.</p>
</div>
<section id="index">
<h2><span class="section-number">1.1. </span>Index<a class="headerlink" href="#index" title="Permalink to this headline">¶</a></h2>
<section id="isotropic-kernels">
<h3><span class="section-number">1.1.1. </span>Isotropic kernels<a class="headerlink" href="#isotropic-kernels" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#lsqfitgp.Constant" title="lsqfitgp.Constant"><code class="xref py py-func docutils literal notranslate"><span class="pre">Constant()</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.ExpQuad" title="lsqfitgp.ExpQuad"><code class="xref py py-func docutils literal notranslate"><span class="pre">ExpQuad()</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.GammaExp" title="lsqfitgp.GammaExp"><code class="xref py py-func docutils literal notranslate"><span class="pre">GammaExp()</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.Matern" title="lsqfitgp.Matern"><code class="xref py py-func docutils literal notranslate"><span class="pre">Matern()</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.Matern12" title="lsqfitgp.Matern12"><code class="xref py py-func docutils literal notranslate"><span class="pre">Matern12()</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.Matern32" title="lsqfitgp.Matern32"><code class="xref py py-func docutils literal notranslate"><span class="pre">Matern32()</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.Matern52" title="lsqfitgp.Matern52"><code class="xref py py-func docutils literal notranslate"><span class="pre">Matern52()</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.PPKernel" title="lsqfitgp.PPKernel"><code class="xref py py-func docutils literal notranslate"><span class="pre">PPKernel()</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.RatQuad" title="lsqfitgp.RatQuad"><code class="xref py py-func docutils literal notranslate"><span class="pre">RatQuad()</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.White" title="lsqfitgp.White"><code class="xref py py-func docutils literal notranslate"><span class="pre">White()</span></code></a></p></li>
</ul>
</div></blockquote>
</section>
<section id="stationary-kernels">
<h3><span class="section-number">1.1.2. </span>Stationary kernels<a class="headerlink" href="#stationary-kernels" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#lsqfitgp.Celerite" title="lsqfitgp.Celerite"><code class="xref py py-func docutils literal notranslate"><span class="pre">Celerite()</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.Cos" title="lsqfitgp.Cos"><code class="xref py py-func docutils literal notranslate"><span class="pre">Cos()</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.Expon" title="lsqfitgp.Expon"><code class="xref py py-func docutils literal notranslate"><span class="pre">Expon()</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.Fourier" title="lsqfitgp.Fourier"><code class="xref py py-func docutils literal notranslate"><span class="pre">Fourier()</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.Harmonic" title="lsqfitgp.Harmonic"><code class="xref py py-func docutils literal notranslate"><span class="pre">Harmonic()</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.Periodic" title="lsqfitgp.Periodic"><code class="xref py py-func docutils literal notranslate"><span class="pre">Periodic()</span></code></a></p></li>
</ul>
</div></blockquote>
</section>
<section id="other-kernels">
<h3><span class="section-number">1.1.3. </span>Other kernels<a class="headerlink" href="#other-kernels" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#lsqfitgp.BagOfWords" title="lsqfitgp.BagOfWords"><code class="xref py py-func docutils literal notranslate"><span class="pre">BagOfWords()</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.BrownianBridge" title="lsqfitgp.BrownianBridge"><code class="xref py py-func docutils literal notranslate"><span class="pre">BrownianBridge()</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.Categorical" title="lsqfitgp.Categorical"><code class="xref py py-func docutils literal notranslate"><span class="pre">Categorical()</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.FracBrownian" title="lsqfitgp.FracBrownian"><code class="xref py py-func docutils literal notranslate"><span class="pre">FracBrownian()</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.Gibbs" title="lsqfitgp.Gibbs"><code class="xref py py-func docutils literal notranslate"><span class="pre">Gibbs()</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.Linear" title="lsqfitgp.Linear"><code class="xref py py-func docutils literal notranslate"><span class="pre">Linear()</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.NNKernel" title="lsqfitgp.NNKernel"><code class="xref py py-func docutils literal notranslate"><span class="pre">NNKernel()</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.OrnsteinUhlenbeck" title="lsqfitgp.OrnsteinUhlenbeck"><code class="xref py py-func docutils literal notranslate"><span class="pre">OrnsteinUhlenbeck()</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.Rescaling" title="lsqfitgp.Rescaling"><code class="xref py py-func docutils literal notranslate"><span class="pre">Rescaling()</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.Taylor" title="lsqfitgp.Taylor"><code class="xref py py-func docutils literal notranslate"><span class="pre">Taylor()</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.Wiener" title="lsqfitgp.Wiener"><code class="xref py py-func docutils literal notranslate"><span class="pre">Wiener()</span></code></a></p></li>
<li><p><a class="reference internal" href="#lsqfitgp.WienerIntegral" title="lsqfitgp.WienerIntegral"><code class="xref py py-func docutils literal notranslate"><span class="pre">WienerIntegral()</span></code></a></p></li>
</ul>
</div></blockquote>
</section>
</section>
<section id="documentation">
<h2><span class="section-number">1.2. </span>Documentation<a class="headerlink" href="#documentation" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="lsqfitgp.BagOfWords">
<span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">BagOfWords</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfitgp.BagOfWords" title="Permalink to this definition">¶</a></dt>
<dd><p>Bag of words kernel.</p>
<div class="math notranslate nohighlight">
\[\begin{split}k(x, y) &amp;= \sum_{w \in \text{words}} c_w(x) c_w(y), \\
c_w(x) &amp;= \text{number of times word $w$ appears in $x$}\end{split}\]</div>
<p>The words are defined as non-empty substrings delimited by spaces or one of
the following punctuation characters: ! « » ” “ ” ‘ ’ / ( ) ‘ ? ¡ ¿ „ ‚ &lt; &gt;
, ; . : - – —.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lsqfitgp.BrownianBridge">
<span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">BrownianBridge</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfitgp.BrownianBridge" title="Permalink to this definition">¶</a></dt>
<dd><p>Brownian bridge kernel.</p>
<div class="math notranslate nohighlight">
\[k(x, y) = \min(x, y) - xy,
\quad x, y \in [0, 1]\]</div>
<p>It is a Wiener process conditioned on being zero at x = 1.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lsqfitgp.Categorical">
<span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">Categorical</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cov</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfitgp.Categorical" title="Permalink to this definition">¶</a></dt>
<dd><p>Categorical kernel.</p>
<div class="math notranslate nohighlight">
\[k(x, y) = \texttt{cov}[x, y]\]</div>
<p>A kernel over integers from 0 to N-1. The parameter <cite>cov</cite> is the covariance
matrix of the values.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lsqfitgp.Celerite">
<span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">Celerite</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">delta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfitgp.Celerite" title="Permalink to this definition">¶</a></dt>
<dd><p>Celerite kernel.</p>
<div class="math notranslate nohighlight">
\[k(x, y) = \exp(-\gamma|x - y|)
\big( \cos(x - y) + B \sin(|x - y|) \big)\]</div>
<p>This is the covariance function of an AR(2) process with complex roots. The
parameters must satisfy the condition <span class="math notranslate nohighlight">\(|B| \le \gamma\)</span>. For
<span class="math notranslate nohighlight">\(B = \gamma\)</span> it is equivalent to the <a class="reference internal" href="#lsqfitgp.Harmonic" title="lsqfitgp.Harmonic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Harmonic</span></code></a> kernel with
<span class="math notranslate nohighlight">\(\eta Q = 1/B, Q &gt; 1\)</span>, and it is derivable.</p>
<p>Reference: Daniel Foreman-Mackey, Eric Agol, Sivaram Ambikasaran, and Ruth
Angus: <em>Fast and Scalable Gaussian Process Modeling With Applications To
Astronomical Time Series</em>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lsqfitgp.Constant">
<span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">Constant</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">r2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfitgp.Constant" title="Permalink to this definition">¶</a></dt>
<dd><p>Constant kernel.</p>
<div class="math notranslate nohighlight">
\[k(r) = 1\]</div>
<p>This means that all points are completely correlated, thus it is equivalent
to fitting with an horizontal line. This can be seen also by observing that
1 = 1 x 1.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lsqfitgp.Cos">
<span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">Cos</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">delta</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfitgp.Cos" title="Permalink to this definition">¶</a></dt>
<dd><p>Cosine kernel.</p>
<div class="math notranslate nohighlight">
\[k(x, y) = \cos(x - y)
= \cos x \cos y + \sin x \sin y\]</div>
<p>Samples from this kernel are harmonic functions. It can be multiplied with
another kernel to introduce anticorrelations.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lsqfitgp.ExpQuad">
<span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">ExpQuad</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">r2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfitgp.ExpQuad" title="Permalink to this definition">¶</a></dt>
<dd><p>Exponential quadratic kernel.</p>
<div class="math notranslate nohighlight">
\[k(r) = \exp \left( -\frac 12 r^2 \right)\]</div>
<p>It is smooth and has a strict typical lengthscale, i.e., oscillations are
strongly suppressed under a certain wavelength, and correlations are
strongly suppressed over a certain distance.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lsqfitgp.Expon">
<span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">Expon</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">delta</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfitgp.Expon" title="Permalink to this definition">¶</a></dt>
<dd><p>Exponential kernel.</p>
<div class="math notranslate nohighlight">
\[k(x, y) = \exp(-|x - y|)\]</div>
<p>In 1D it is equivalent to the Matérn 1/2 kernel, however in more dimensions
it acts separately while the Matérn kernel is isotropic.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lsqfitgp.Fourier">
<span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">Fourier</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">delta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfitgp.Fourier" title="Permalink to this definition">¶</a></dt>
<dd><p>Fourier kernel.</p>
<div class="math notranslate nohighlight">
\[\begin{split}k(x, y) &amp;= \frac1{\zeta(2n)} \sum_{k=1}^\infty
\frac {\cos(2\pi kx)}{k^n} \frac {\cos(2\pi ky)}{k^n}
+ \frac1{\zeta(2n)} \sum_{k=1}^\infty
\frac {\sin(2\pi kx)}{k^n} \frac {\sin(2\pi ky)}{k^n} = \\
&amp;= \frac1{\zeta(2n)} \sum_{k=1}^\infty
\frac {\cos(2\pi k(x-y))} {k^{2n}} = \\
&amp;= (-1)^{n+1}
\frac1{\zeta(2n)} \frac {(2\pi)^{2n}} {2(2n)!}
B_{2n}(x-y \bmod 1),\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(B_s(x)\)</span> is a Bernoulli polynomial. It is equivalent to fitting
with a Fourier series of period 1 with independent priors on the
coefficients with mean zero and variance
<span class="math notranslate nohighlight">\(1/(\zeta(2n)k^{2n})\)</span>. The process is <span class="math notranslate nohighlight">\(n - 1\)</span> times
derivable.</p>
<p>Note that the <span class="math notranslate nohighlight">\(k = 0\)</span> term is not included in the summation, so the
mean of the process over one period is forced to be zero.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lsqfitgp.FracBrownian">
<span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">FracBrownian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfitgp.FracBrownian" title="Permalink to this definition">¶</a></dt>
<dd><p>Fractional brownian motion kernel.</p>
<div class="math notranslate nohighlight">
\[k(x, y) = \frac 12 (x^{2H} + y^{2H} - |x-y|^{2H}),
\quad H \in (0, 1), \quad x, y \ge 0\]</div>
<p>For <cite>H</cite> = 1/2 (default) it is the Wiener kernel. For <cite>H</cite> in (0, 1/2) the
increments are anticorrelated (strong oscillation), for <cite>H</cite> in (1/2, 1)
the increments are correlated (tends to keep a slope).</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lsqfitgp.GammaExp">
<span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">GammaExp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">r</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfitgp.GammaExp" title="Permalink to this definition">¶</a></dt>
<dd><p>Gamma exponential kernel.</p>
<div class="math notranslate nohighlight">
\[k(r) = \exp(-r^\texttt{gamma}), \quad
\texttt{gamma} \in [0, 2]\]</div>
<p>For <cite>gamma</cite> = 2 it is the Gaussian kernel, for <cite>gamma</cite> = 1 it is the Matérn
1/2 kernel, for <cite>gamma</cite> = 0 it is the constant kernel. The process is
differentiable only for <cite>gamma</cite> = 2, however as <cite>gamma</cite> gets closer to 2
the variance of the non-derivable component goes to zero.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lsqfitgp.Gibbs">
<span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">Gibbs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scalefun=&lt;function</span> <span class="pre">&lt;lambda&gt;&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfitgp.Gibbs" title="Permalink to this definition">¶</a></dt>
<dd><p>Gibbs kernel.</p>
<div class="math notranslate nohighlight">
\[k(x, y) = \sqrt{ \frac {2 s(x) s(y)} {s(x)^2 + s(y)^2} }
\exp \left( -\frac {(x - y)^2} {s(x)^2 + s(y)^2} \right),
\quad s = \texttt{scalefun}.\]</div>
<p>Kernel which in some sense is like a Gaussian kernel where the scale
changes at every point. The scale is computed by the parameter <cite>scalefun</cite>
which must be a callable taking the x array and returning a scale for each
point. By default <cite>scalefun</cite> returns 1 so it is a Gaussian kernel.</p>
<p>Consider that the default parameter <cite>scale</cite> acts before <cite>scalefun</cite>, so
for example if <cite>scalefun(x) = x</cite> then <cite>scale</cite> has no effect. You should
include all rescalings in <cite>scalefun</cite> to avoid surprises.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lsqfitgp.Harmonic">
<span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">Harmonic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">delta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Q</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfitgp.Harmonic" title="Permalink to this definition">¶</a></dt>
<dd><p>Damped stochastically driven harmonic oscillator kernel.</p>
<div class="math notranslate nohighlight">
\[\begin{split}k(x, y) =
\exp\left( -\frac {\tau} {Q} \right)
\begin{cases}
    \cosh(\eta\tau) + \sinh(\eta\tau) / (\eta Q)
    &amp; 0 &lt; Q &lt; 1 \\
    1 + \tau &amp; Q = 1 \\
    \cos(\eta\tau) + \sin(\eta\tau) / (\eta Q)
    &amp; Q &gt; 1,
\end{cases}\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\tau = |x - y|\)</span> and <span class="math notranslate nohighlight">\(\eta = \sqrt{|1 - 1/Q^2|}\)</span>.</p>
<p>The process is the solution to the stochastic differential equation</p>
<div class="math notranslate nohighlight">
\[f''(x) + 2/Q f'(x) + f(x) = w(x),\]</div>
<p>where <cite>w</cite> is white noise.</p>
<p>The parameter <cite>Q</cite> is the quality factor, i.e., the ratio between the energy
stored in the oscillator and the energy lost in each cycle due to damping.
The angular frequency is 1, i.e., the period is 2π. The process is derivable
one time.</p>
<p>In 1D, for <cite>Q</cite> = 1 (default) and <cite>scale</cite> = sqrt(1/3), it is the Matérn 3/2
kernel.</p>
<p>Reference: Daniel Foreman-Mackey, Eric Agol, Sivaram Ambikasaran, and Ruth
Angus: <em>Fast and Scalable Gaussian Process Modeling With Applications To
Astronomical Time Series</em>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lsqfitgp.Linear">
<span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">Linear</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfitgp.Linear" title="Permalink to this definition">¶</a></dt>
<dd><p>Dot product kernel.</p>
<div class="math notranslate nohighlight">
\[k(x, y) = x \cdot y = \sum_i x_i y_i\]</div>
<p>In 1D it is equivalent to fitting with a line passing by the origin.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lsqfitgp.Matern">
<span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">Matern</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">r</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nu</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfitgp.Matern" title="Permalink to this definition">¶</a></dt>
<dd><p>Matérn kernel of real order.</p>
<div class="math notranslate nohighlight">
\[k(r) = \frac {2^{1-\nu}} {\Gamma(\nu)} x^\nu K_\nu(x),
\quad \nu = \texttt{nu} &gt; 0,
\quad x = \sqrt{2\nu} r\]</div>
<p>The nearest integer below <cite>nu</cite> indicates how many times the Gaussian
process is derivable: so for <cite>nu</cite> &lt; 1 it is continuous but not derivable,
for 1 &lt;= <cite>nu</cite> &lt; 2 it is derivable but has not a decond derivative, etc. The
half-integer case (nu = 1/2, 3/2, …) uses internally a simpler formula so
you should prefer it. Also, taking derivatives of the process is supported
only for half-integer nu.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lsqfitgp.Matern12">
<span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">Matern12</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">r</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfitgp.Matern12" title="Permalink to this definition">¶</a></dt>
<dd><p>Matérn kernel of order 1/2 (continuous, not derivable).</p>
<div class="math notranslate nohighlight">
\[k(r) = \exp(-r)\]</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lsqfitgp.Matern32">
<span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">Matern32</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">r</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfitgp.Matern32" title="Permalink to this definition">¶</a></dt>
<dd><p>Matérn kernel of order 3/2 (derivable one time).</p>
<div class="math notranslate nohighlight">
\[k(r) = (1 + x) \exp(-x), \quad x = \sqrt3 r\]</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lsqfitgp.Matern52">
<span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">Matern52</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">r</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfitgp.Matern52" title="Permalink to this definition">¶</a></dt>
<dd><p>Matérn kernel of order 5/2 (derivable two times).</p>
<div class="math notranslate nohighlight">
\[k(r) = (1 + x + x^2/3) \exp(-x), \quad x = \sqrt5 r\]</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lsqfitgp.NNKernel">
<span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">NNKernel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfitgp.NNKernel" title="Permalink to this definition">¶</a></dt>
<dd><p>Neural network kernel.</p>
<div class="math notranslate nohighlight">
\[k(x, y) = \frac 2 \pi
\arcsin \left( \frac
{
    2 (q + x \cdot y)
}{
    (1 + 2 (q + x \cdot x))
    (1 + 2 (q + y \cdot y))
}
\right),
\quad q = \texttt{sigma0}^2\]</div>
<p>Kernel which is equivalent to a neural network with one infinite hidden
layer with Gaussian priors on the weights and error function response. In
other words, you can think of the process as a superposition of sigmoids
where <cite>sigma0</cite> sets the dispersion of the centers of the sigmoids.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lsqfitgp.OrnsteinUhlenbeck">
<span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">OrnsteinUhlenbeck</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfitgp.OrnsteinUhlenbeck" title="Permalink to this definition">¶</a></dt>
<dd><p>Ornstein-Uhlenbeck process kernel.</p>
<div class="math notranslate nohighlight">
\[k(x, y) = \exp(-|x - y|) - \exp(-(x + y)),
\quad x, y \ge 0\]</div>
<p>It is a random walk plus a negative feedback term that keeps the
asymptotical variance constant. It is asymptotically stationary; often the
name “Ornstein-Uhlenbeck” is given to the stationary part only, which here
is provided as <a class="reference internal" href="#lsqfitgp.Expon" title="lsqfitgp.Expon"><code class="xref py py-class docutils literal notranslate"><span class="pre">Expon</span></code></a>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lsqfitgp.PPKernel">
<span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">PPKernel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">r</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">D</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfitgp.PPKernel" title="Permalink to this definition">¶</a></dt>
<dd><p>Piecewise polynomial kernel.</p>
<div class="math notranslate nohighlight">
\[\begin{split}k(r) = \text{polynomial}_{q,D}(r)
\begin{cases}
    1 - r &amp; r \in [0, 1)     \\
    0     &amp; \text{otherwise}
\end{cases}\end{split}\]</div>
<p>An isotropic kernel with finite support. The covariance is nonzero only
when the distance between the points is less than 1. Parameter <cite>q</cite> in (0,
1, 2, 3) sets the differentiability, while parameter <cite>D</cite> sets the maximum
dimensionality the kernel can be used with. Default is <cite>q</cite> = 0 (non
derivable), <cite>D</cite> = 1 (can be used only in 1D).</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lsqfitgp.Periodic">
<span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">Periodic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">delta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">outerscale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfitgp.Periodic" title="Permalink to this definition">¶</a></dt>
<dd><p>Periodic Gaussian kernel.</p>
<div class="math notranslate nohighlight">
\[k(x, y) = \exp \left(
-2 \left(
\frac {\sin((x - y) / 2)} {\texttt{outerscale}}
\right)^2
\right)\]</div>
<p>A Gaussian kernel over a transformed periodic space. It represents a
periodic process. The usual <cite>scale</cite> parameter sets the period, with the
default <cite>scale</cite> = 1 giving a period of 2π, while the <cite>outerscale</cite> parameter
sets the length scale of the correlations.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lsqfitgp.RatQuad">
<span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">RatQuad</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">r2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfitgp.RatQuad" title="Permalink to this definition">¶</a></dt>
<dd><p>Rational quadratic kernel.</p>
<div class="math notranslate nohighlight">
\[k(r) = \left( 1 + \frac {r^2} {2 \alpha} \right)^{-\alpha},
\quad \alpha = \texttt{alpha}\]</div>
<p>It is equivalent to a lengthscale mixture of Gaussian kernels where the
scale distribution is a gamma with shape parameter <cite>alpha</cite>. For <cite>alpha</cite> -&gt;
infinity, it becomes the Gaussian kernel. It is smooth.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lsqfitgp.Rescaling">
<span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">Rescaling</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stdfun</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfitgp.Rescaling" title="Permalink to this definition">¶</a></dt>
<dd><p>Outer product kernel.</p>
<div class="math notranslate nohighlight">
\[k(x, y) = \texttt{stdfun}(x) \texttt{stdfun}(y)\]</div>
<p>A totally correlated kernel with arbitrary variance. Parameter <cite>stdfun</cite>
must be a function that takes <cite>x</cite> or <cite>y</cite> and computes the standard
deviation at the point. It can yield negative values; points with the same
sign of <cite>fun</cite> will be totally correlated, points with different sign will
be totally anticorrelated. Use this kernel to modulate the variance of
other kernels. By default <cite>stdfun</cite> returns a constant, so it is equivalent
to <a class="reference internal" href="#lsqfitgp.Constant" title="lsqfitgp.Constant"><code class="xref py py-class docutils literal notranslate"><span class="pre">Constant</span></code></a>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lsqfitgp.Taylor">
<span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">Taylor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfitgp.Taylor" title="Permalink to this definition">¶</a></dt>
<dd><p>Exponential-like power series kernel.</p>
<div class="math notranslate nohighlight">
\[k(x, y) = \sum_{k=0}^\infty \frac {x^k}{k!} \frac {y^k}{k!}
= I_0(2 \sqrt{xy})\]</div>
<p>It is equivalent to fitting with a Taylor series expansion in zero with
independent priors on the coefficients k with mean zero and standard
deviation 1/k!.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lsqfitgp.White">
<span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">White</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">r2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfitgp.White" title="Permalink to this definition">¶</a></dt>
<dd><p>White noise kernel.</p>
<div class="math notranslate nohighlight">
\[\begin{split}k(x, y) = \begin{cases}
    1 &amp; x = y     \\
    0 &amp; x \neq y
\end{cases}\end{split}\]</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lsqfitgp.Wiener">
<span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">Wiener</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfitgp.Wiener" title="Permalink to this definition">¶</a></dt>
<dd><p>Wiener kernel.</p>
<div class="math notranslate nohighlight">
\[k(x, y) = \min(x, y), \quad x, y &gt; 0\]</div>
<p>A kernel representing a non-differentiable random walk starting at 0.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lsqfitgp.WienerIntegral">
<span class="sig-prename descclassname"><span class="pre">lsqfitgp.</span></span><span class="sig-name descname"><span class="pre">WienerIntegral</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfitgp.WienerIntegral" title="Permalink to this definition">¶</a></dt>
<dd><p>Kernel for a process whose derivative is a Wiener process.</p>
<div class="math notranslate nohighlight">
\[\begin{split}k(x, y) = \frac 12 \begin{cases}
    x^2 (y - x/3) &amp; x &lt; y, \\
    y^2 (x - y/3) &amp; y \le x
\end{cases}\end{split}\]</div>
</dd></dl>

</section>
</section>


          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="reference.html" title="Previous document">Reference manual</a>
        </li>
        <li>
          <a href="kernel.html" title="Next document"><span class="section-number">2. </span>Generic kernel classes</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;2020-2022, Giacomo Petrillo.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.5.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/kernelsref.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>